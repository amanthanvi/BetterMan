{
  "name": "xz",
  "section": 1,
  "title": "xz manual page",
  "description": "xz is a general-purpose data compression tool with command line syntax similar to gzip(1) and bzip2(1).",
  "synopsis": "xz [option...] [file...] COMMAND ALIASES unxz is equivalent to xz --decompress. xzcat is equivalent to xz --decompress --stdout. lzma is equivalent to xz --format=lzma. unlzma is equivalent to xz --format=lzma --decompress. lzcat is equivalent to xz --format=lzma --decompress --stdout. When writing scripts that need to decompress files, it is recommended to always use the name xz with appropriate arguments (xz -d or xz -dc) instead of the names unxz and xzcat.",
  "category": "User Commands",
  "sections": [
    {
      "id": "name",
      "title": "NAME",
      "content": "Tukaani \t\t\t  2025-03-08\t\t\t\t XZ(1)",
      "level": 1,
      "subsections": [],
      "codeBlocks": [
        "       xz, unxz, xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and\n       .lzma files\n",
        "       xz [option...] [file...]\n",
        "       unxz is equivalent to xz --decompress.\n       xzcat is equivalent to xz --decompress --stdout.\n       lzma is equivalent to xz --format=lzma.\n       unlzma is equivalent to xz --format=lzma --decompress.\n       lzcat is equivalent to xz --format=lzma --decompress --stdout.\n\n       When writing scripts that need to decompress files, it is recommended\n       to always use the name xz with appropriate arguments (xz -d or xz -dc)\n       instead of the names unxz and xzcat.\n",
        "       xz is a general-purpose data compression tool with command line syntax\n       similar to gzip(1) and bzip2(1).  The native file format is the .xz\n       format, but the legacy .lzma format used by LZMA Utils and raw\n       compressed streams with no container format headers are also supported.\n       In addition, decompression of the .lz format used by lzip is supported.\n\n       xz compresses or decompresses each file according to the selected\n       operation mode.\tIf no files are given or file is -, xz reads from\n       standard input and writes the processed data to standard output.  xz\n       will refuse (display an error and skip the file) to write compressed\n       data to standard output if it is a terminal.  Similarly, xz will refuse\n       to read compressed data from standard input if it is a terminal.\n\n       Unless --stdout is specified, files other than - are written to a new\n       file whose name is derived from the source file name:\n\n       •  When compressing, the suffix of the target file format (.xz or",
        "       •  When decompressing, the .xz, .lzma, or .lz suffix is removed from",
        "       If the target file already exists, an error is displayed and the file\n       is skipped.\n\n       Unless writing to standard output, xz will display a warning and skip\n       the file if any of the following applies:\n\n       •  File is not a regular file.  Symbolic links are not followed, and",
        "       •  File has more than one hard link.\n\n       •  File has setuid, setgid, or sticky bit set.\n\n       •  The operation mode is set to compress and the file already has a",
        "       •  The operation mode is set to decompress and the file doesn't have a",
        "       After successfully compressing or decompressing the file, xz copies the\n       owner, group, permissions, access time, and modification time from the\n       source file to the target file.\tIf copying the group fails, the\n       permissions are modified so that the target file doesn't become\n       accessible to users who didn't have permission to access the source\n       file.  xz doesn't support copying other metadata like access control\n       lists or extended attributes yet.\n\n       Once the target file has been successfully closed, the source file is\n       removed unless --keep was specified.  The source file is never removed\n       if the output is written to standard output or if an error occurs.\n\n       Sending SIGINFO or SIGUSR1 to the xz process makes it print progress\n       information to standard error.  This has only limited use since when\n       standard error is a terminal, using --verbose will display an\n       automatically updating progress indicator.\n",
        "       The memory usage of xz varies from a few hundred kilobytes to several\n       gigabytes depending on the compression settings.  The settings used\n       when compressing a file determine the memory requirements of the\n       decompressor.  Typically the decompressor needs 5 % to 20 % of the\n       amount of memory that the compressor needed when creating the file.\n       For example, decompressing a file created with xz -9 currently requires\n       65 MiB of memory.  Still, it is possible to have .xz files that require\n       several gigabytes of memory to decompress.\n\n       Especially users of older systems may find the possibility of very\n       large memory usage annoying.  To prevent uncomfortable surprises, xz\n       has a built-in memory usage limiter, which is disabled by default.\n       While some operating systems provide ways to limit the memory usage of\n       processes, relying on it wasn't deemed to be flexible enough (for\n       example, using ulimit(1) to limit virtual memory tends to cripple\n       mmap(2)).\n\n       The memory usage limiter can be enabled with the command line option\n       --memlimit=limit.  Often it is more convenient to enable the limiter by\n       default by setting the environment variable XZ_DEFAULTS, for example,\n       XZ_DEFAULTS=--memlimit=150MiB.  It is possible to set the limits\n       separately for compression and decompression by using\n       --memlimit-compress=limit and --memlimit-decompress=limit.  Using these\n       two options outside XZ_DEFAULTS is rarely useful because a single run\n       of xz cannot do both compression and decompression and --memlimit=limit\n       (or -M limit) is shorter to type on the command line.\n\n       If the specified memory usage limit is exceeded when decompressing, xz\n       will display an error and decompressing the file will fail.  If the\n       limit is exceeded when compressing, xz will try to scale the settings\n       down so that the limit is no longer exceeded (except when using\n       --format=raw or --no-adjust).  This way the operation won't fail unless\n       the limit is very small.  The scaling of the settings is done in steps\n       that don't match the compression level presets, for example, if the\n       limit is only slightly less than the amount required for xz -9, the\n       settings will be scaled down only a little, not all the way down to xz\n       -8.\n",
        "       It is possible to concatenate .xz files as is.  xz will decompress such\n       files as if they were a single .xz file.\n\n       It is possible to insert padding between the concatenated parts or\n       after the last part.  The padding must consist of null bytes and the\n       size of the padding must be a multiple of four bytes.  This can be\n       useful, for example, if the .xz file is stored on a medium that\n       measures file sizes in 512-byte blocks.\n\n       Concatenation and padding are not allowed with .lzma files or raw\n       streams.\n",
        "       In most places where an integer argument is expected, an optional\n       suffix is supported to easily indicate large integers.  There must be\n       no space between the integer and the suffix.\n\n       KiB    Multiply the integer by 1,024 (2^10).  Ki, k, kB, K, and KB are\n\t      accepted as synonyms for KiB.\n\n       MiB    Multiply the integer by 1,048,576 (2^20).  Mi, m, M, and MB are\n\t      accepted as synonyms for MiB.\n\n       GiB    Multiply the integer by 1,073,741,824 (2^30).  Gi, g, G, and GB\n\t      are accepted as synonyms for GiB.\n\n       The special value max can be used to indicate the maximum integer value\n       supported by the option.\n",
        "       If multiple operation mode options are given, the last one takes\n       effect.\n\n       -z, --compress\n\t      Compress.  This is the default operation mode when no operation\n\t      mode option is specified and no other operation mode is implied\n\t      from the command name (for example, unxz implies --decompress).\n\n\n\t      After successful compression, the source file is removed unless\n\t      writing to standard output or --keep was specified.\n\n       -d, --decompress, --uncompress\n\t      Decompress.  After successful decompression, the source file is\n\t      removed unless writing to standard output or --keep was\n\t      specified.\n\n       -t, --test\n\t      Test the integrity of compressed files.  This option is\n\t      equivalent to --decompress --stdout except that the decompressed\n\t      data is discarded instead of being written to standard output.\n\t      No files are created or removed.\n\n       -l, --list\n\t      Print information about compressed files.  No uncompressed\n\t      output is produced, and no files are created or removed.\tIn\n\t      list mode, the program cannot read the compressed data from\n\t      standard input or from other unseekable sources.\n\n\n\t      The default listing shows basic information about files, one\n\t      file per line.  To get more detailed information, use also the\n\t      --verbose option.  For even more information, use --verbose\n\t      twice, but note that this may be slow, because getting all the\n\t      extra information requires many seeks.  The width of verbose\n\t      output exceeds 80 characters, so piping the output to, for\n\t      example, less -S may be convenient if the terminal isn't wide\n\t      enough.\n\n\n\t      The exact output may vary between xz versions and different\n\t      locales.\tFor machine-readable output, --robot --list should be\n\t      used.\n",
        "       -k, --keep\n\t      Don't delete the input files.\n\n\n\t      Since xz 5.2.6, this option also makes xz compress or decompress\n\t      even if the input is a symbolic link to a regular file, has more\n\t      than one hard link, or has the setuid, setgid, or sticky bit\n\t      set.  The setuid, setgid, and sticky bits are not copied to the\n\t      target file.  In earlier versions this was only done with\n\t      --force.\n\n       -f, --force\n\t      This option has several effects:\n\n\t      •  If the target file already exists, delete it before",
        "\t      •  Compress or decompress even if the input is a symbolic link",
        "\t      •  When used with --decompress --stdout and xz cannot recognize",
        "       -c, --stdout, --to-stdout\n\t      Write the compressed or decompressed data to standard output\n\t      instead of a file.  This implies --keep.\n\n       --single-stream\n\t      Decompress only the first .xz stream, and silently ignore\n\t      possible remaining input data following the stream.  Normally\n\t      such trailing garbage makes xz display an error.\n\n\n\t      xz never decompresses more than one stream from .lzma files or\n\t      raw streams, but this option still makes xz ignore the possible\n\t      trailing data after the .lzma file or raw stream.\n\n\n\t      This option has no effect if the operation mode is not\n\t      --decompress or --test.\n\n\n\t      Since xz 5.7.1alpha, --single-stream implies --keep.\n\n       --no-sparse\n\t      Disable creation of sparse files.  By default, if decompressing\n\t      into a regular file, xz tries to make the file sparse if the\n\t      decompressed data contains long sequences of binary zeros.  It\n\t      also works when writing to standard output as long as standard\n\t      output is connected to a regular file and certain additional\n\t      conditions are met to make it safe.  Creating sparse files may\n\t      save disk space and speed up the decompression by reducing the\n\t      amount of disk I/O.\n\n       -S .suf, --suffix=.suf\n\t      When compressing, use .suf as the suffix for the target file\n\t      instead of .xz or .lzma.\tIf not writing to standard output and\n\t      the source file already has the suffix .suf, a warning is\n\t      displayed and the file is skipped.\n\n\n\t      When decompressing, recognize files with the suffix .suf in\n\t      addition to files with the .xz, .txz, .lzma, .tlz, or .lz\n\t      suffix.  If the source file has the suffix .suf, the suffix is\n\t      removed to get the target filename.\n\n\n\t      When compressing or decompressing raw streams (--format=raw),\n\t      the suffix must always be specified unless writing to standard\n\t      output, because there is no default suffix for raw streams.\n\n       --files[=file]\n\t      Read the filenames to process from file; if file is omitted,\n\t      filenames are read from standard input.  Filenames must be\n\t      terminated with the newline character.  A dash (-) is taken as a\n\t      regular filename; it doesn't mean standard input.  If filenames\n\t      are given also as command line arguments, they are processed\n\t      before the filenames read from file.\n\n       --files0[=file]\n\t      This is identical to --files[=file] except that each filename\n\t      must be terminated with the null character.\n",
        "       -F format, --format=format\n\t      Specify the file format to compress or decompress:\n\n\t      auto   This is the default.  When compressing, auto is\n\t\t     equivalent to xz.\tWhen decompressing, the format of the\n\t\t     input file is automatically detected.  Note that raw\n\t\t     streams (created with --format=raw) cannot be auto-\n\t\t     detected.\n\n\t      xz     Compress to the .xz file format, or accept only .xz files\n\t\t     when decompressing.\n\n\t      lzma, alone\n\t\t     Compress to the legacy .lzma file format, or accept only\n\t\t     .lzma files when decompressing.  The alternative name\n\t\t     alone is provided for backwards compatibility with LZMA\n\t\t     Utils.\n\n\t      lzip   Accept only .lz files when decompressing.\tCompression is\n\t\t     not supported.\n\n\n\t\t     The .lz format version 0 and the unextended version 1 are\n\t\t     supported.  Version 0 files were produced by lzip 1.3 and\n\t\t     older.  Such files aren't common but may be found from\n\t\t     file archives as a few source packages were released in\n\t\t     this format.  People might have old personal files in\n\t\t     this format too.  Decompression support for the format\n\t\t     version 0 was removed in lzip 1.18.\n\n\n\t\t     lzip 1.4 and later create files in the format version 1.\n\t\t     The sync flush marker extension to the format version 1\n\t\t     was added in lzip 1.6.  This extension is rarely used and\n\t\t     isn't supported by xz (diagnosed as corrupt input).\n\n\t      raw    Compress or uncompress a raw stream (no headers).\tThis\n\t\t     is meant for advanced users only.\tTo decode raw streams,\n\t\t     you need use --format=raw and explicitly specify the\n\t\t     filter chain, which normally would have been stored in\n\t\t     the container headers.\n\n       -C check, --check=check\n\t      Specify the type of the integrity check.\tThe check is\n\t      calculated from the uncompressed data and stored in the .xz\n\t      file.  This option has an effect only when compressing into the\n\t      .xz format; the .lzma format doesn't support integrity checks.\n\t      The integrity check (if any) is verified when the .xz file is\n\t      decompressed.\n\n\n\t      Supported check types:\n\n\t      none   Don't calculate an integrity check at all.  This is\n\t\t     usually a bad idea.  This can be useful when integrity of\n\t\t     the data is verified by other means anyway.\n\n\t      crc32  Calculate CRC32 using the polynomial from IEEE-802.3\n\t\t     (Ethernet).\n\n\t      crc64  Calculate CRC64 using the polynomial from ECMA-182.  This\n\t\t     is the default, since it is slightly better than CRC32 at\n\t\t     detecting damaged files and the speed difference is\n\t\t     negligible.\n\n\t      sha256 Calculate SHA-256.  This is somewhat slower than CRC32\n\t\t     and CRC64.\n\n\n\t      Integrity of the .xz headers is always verified with CRC32.  It\n\t      is not possible to change or disable it.\n\n       --ignore-check\n\t      Don't verify the integrity check of the compressed data when\n\t      decompressing.  The CRC32 values in the .xz headers will still\n\t      be verified normally.\n\n\n\t      Do not use this option unless you know what you are doing.\n\t      Possible reasons to use this option:\n\n\t      •  Trying to recover data from a corrupt .xz file.\n\n\t      •  Speeding up decompression.  This matters mostly with SHA-256",
        "       -0 ... -9\n\t      Select a compression preset level.  The default is -6.  If\n\t      multiple preset levels are specified, the last one takes effect.\n\t      If a custom filter chain was already specified, setting a\n\t      compression preset level clears the custom filter chain.\n\n\n\t      The differences between the presets are more significant than\n\t      with gzip(1) and bzip2(1).  The selected compression settings\n\t      determine the memory requirements of the decompressor, thus\n\t      using a too high preset level might make it painful to\n\t      decompress the file on an old system with little RAM.\n\t      Specifically, it's not a good idea to blindly use -9 for\n\t      everything like it often is with gzip(1) and bzip2(1).\n\n\t      -0 ... -3\n\t\t     These are somewhat fast presets.  -0 is sometimes faster\n\t\t     than gzip -9 while compressing much better.  The higher\n\t\t     ones often have speed comparable to bzip2(1) with\n\t\t     comparable or better compression ratio, although the\n\t\t     results depend a lot on the type of data being\n\t\t     compressed.\n\n\t      -4 ... -6\n\t\t     Good to very good compression while keeping decompressor\n\t\t     memory usage reasonable even for old systems.  -6 is the\n\t\t     default, which is usually a good choice for distributing\n\t\t     files that need to be decompressible even on systems with\n\t\t     only 16 MiB RAM.  (-5e or -6e may be worth considering\n\t\t     too.  See --extreme.)\n\n\t      -7 ... -9\n\t\t     These are like -6 but with higher compressor and\n\t\t     decompressor memory requirements.\tThese are useful only\n\t\t     when compressing files bigger than 8 MiB, 16 MiB, and\n\t\t     32 MiB, respectively.\n\n\n\t      On the same hardware, the decompression speed is approximately a\n\t      constant number of bytes of compressed data per second.  In\n\t      other words, the better the compression, the faster the\n\t      decompression will usually be.  This also means that the amount\n\t      of uncompressed output produced per second can vary a lot.\n\n\n\t      The following table summarises the features of the presets:\n\n\t\t     Preset   DictSize\t CompCPU   CompMem   DecMem\n\t\t       -0     256 KiB\t    0\t     3 MiB    1 MiB\n\t\t       -1\t1 MiB\t    1\t     9 MiB    2 MiB\n\t\t       -2\t2 MiB\t    2\t    17 MiB    3 MiB\n\t\t       -3\t4 MiB\t    3\t    32 MiB    5 MiB\n\t\t       -4\t4 MiB\t    4\t    48 MiB    5 MiB\n\t\t       -5\t8 MiB\t    5\t    94 MiB    9 MiB\n\t\t       -6\t8 MiB\t    6\t    94 MiB    9 MiB\n\t\t       -7      16 MiB\t    6\t   186 MiB   17 MiB\n\t\t       -8      32 MiB\t    6\t   370 MiB   33 MiB\n\t\t       -9      64 MiB\t    6\t   674 MiB   65 MiB\n\n\n\t      Column descriptions:\n\n\t      •  DictSize is the LZMA2 dictionary size.  It is waste of memory",
        "\t      •  CompCPU is a simplified representation of the LZMA2 settings",
        "\t      •  CompMem contains the compressor memory requirements in the",
        "\t      •  DecMem contains the decompressor memory requirements.\tThat",
        "\t      Memory requirements of the multi-threaded mode are significantly\n\t      higher than that of the single-threaded mode.  With the default\n\t      value of --block-size, each thread needs 3*3*DictSize plus\n\t      CompMem or DecMem.  For example, four threads with preset -6\n\t      needs 660–670 MiB of memory.\n\n       -e, --extreme\n\t      Use a slower variant of the selected compression preset level\n\t      (-0 ... -9) to hopefully get a little bit better compression\n\t      ratio, but with bad luck this can also make it worse.\n\t      Decompressor memory usage is not affected, but compressor memory\n\t      usage increases a little at preset levels -0 ... -3.\n\n\n\t      Since there are two presets with dictionary sizes 4 MiB and\n\t      8 MiB, the presets -3e and -5e use slightly faster settings\n\t      (lower CompCPU) than -4e and -6e, respectively.  That way no two\n\t      presets are identical.\n\n\t\t     Preset   DictSize\t CompCPU   CompMem   DecMem\n\t\t      -0e     256 KiB\t    8\t     4 MiB    1 MiB\n\t\t      -1e\t1 MiB\t    8\t    13 MiB    2 MiB\n\t\t      -2e\t2 MiB\t    8\t    25 MiB    3 MiB\n\t\t      -3e\t4 MiB\t    7\t    48 MiB    5 MiB\n\t\t      -4e\t4 MiB\t    8\t    48 MiB    5 MiB\n\t\t      -5e\t8 MiB\t    7\t    94 MiB    9 MiB\n\t\t      -6e\t8 MiB\t    8\t    94 MiB    9 MiB\n\t\t      -7e      16 MiB\t    8\t   186 MiB   17 MiB\n\t\t      -8e      32 MiB\t    8\t   370 MiB   33 MiB\n\t\t      -9e      64 MiB\t    8\t   674 MiB   65 MiB\n\n\n\t      For example, there are a total of four presets that use 8 MiB\n\t      dictionary, whose order from the fastest to the slowest is -5,\n\t      -6, -5e, and -6e.\n\n       --fast\n       --best These are somewhat misleading aliases for -0 and -9,\n\t      respectively.  These are provided only for backwards\n\t      compatibility with LZMA Utils.  Avoid using these options.\n\n       --block-size=size\n\t      When compressing to the .xz format, split the input data into\n\t      blocks of size bytes.  The blocks are compressed independently\n\t      from each other, which helps with multi-threading and makes\n\t      limited random-access decompression possible.  This option is\n\t      typically used to override the default block size in multi-\n\t      threaded mode, but this option can be used in single-threaded\n\t      mode too.\n\n\n\t      In multi-threaded mode about three times size bytes will be\n\t      allocated in each thread for buffering input and output.\tThe\n\t      default size is three times the LZMA2 dictionary size or 1 MiB,\n\t      whichever is more.  Typically a good value is 2–4 times the size\n\t      of the LZMA2 dictionary or at least 1 MiB.  Using size less than\n\t      the LZMA2 dictionary size is waste of RAM because then the LZMA2\n\t      dictionary buffer will never get fully used.  In multi-threaded\n\t      mode, the sizes of the blocks are stored in the block headers.\n\t      This size information is required for multi-threaded\n\t      decompression.\n\n\n\t      In single-threaded mode no block splitting is done by default.\n\t      Setting this option doesn't affect memory usage.\tNo size\n\t      information is stored in block headers, thus files created in\n\t      single-threaded mode won't be identical to files created in\n\t      multi-threaded mode.  The lack of size information also means\n\t      that xz won't be able decompress the files in multi-threaded\n\t      mode.\n\n       --block-list=items\n\t      When compressing to the .xz format, start a new block with an\n\t      optional custom filter chain after the given intervals of\n\t      uncompressed data.\n\n\n\t      The items are a comma-separated list.  Each item consists of an\n\t      optional filter chain number between 0 and 9 followed by a colon\n\t      (:) and a required size of uncompressed data.  Omitting an item\n\t      (two or more consecutive commas) is a shorthand to use the size\n\t      and filters of the previous item.\n\n\n\t      If the input file is bigger than the sum of the sizes in items,\n\t      the last item is repeated until the end of the file.  A special\n\t      value of 0 may be used as the last size to indicate that the\n\t      rest of the file should be encoded as a single block.\n\n\n\t      An alternative filter chain for each block can be specified in\n\t      combination with the --filters1=filters ... --filters9=filters\n\t      options.\tThese options define filter chains with an identifier\n\t      between 1–9.  Filter chain 0 can be used to refer to the default\n\t      filter chain, which is the same as not specifying a filter\n\t      chain.  The filter chain identifier can be used before the\n\t      uncompressed size, followed by a colon (:).  For example, if one\n\t      specifies --block-list=1:2MiB,3:2MiB,2:4MiB,,2MiB,0:4MiB then\n\t      blocks will be created using:\n\n\t      •  The filter chain specified by --filters1 and 2 MiB input\n\n\t      •  The filter chain specified by --filters3 and 2 MiB input\n\n\t      •  The filter chain specified by --filters2 and 4 MiB input\n\n\t      •  The filter chain specified by --filters2 and 4 MiB input\n\n\t      •  The default filter chain and 2 MiB input\n\n\t      •  The default filter chain and 4 MiB input for every block",
        "\t      If one specifies a size that exceeds the encoder's block size\n\t      (either the default value in threaded mode or the value\n\t      specified with --block-size=size), the encoder will create\n\t      additional blocks while keeping the boundaries specified in\n\t      items.  For example, if one specifies --block-size=10MiB\n\t      --block-list=5MiB,10MiB,8MiB,12MiB,24MiB and the input file is\n\t      80 MiB, one will get 11 blocks: 5, 10, 8, 10, 2, 10, 10, 4, 10,\n\t      10, and 1 MiB.\n\n\n\t      In multi-threaded mode the sizes of the blocks are stored in the\n\t      block headers.  This isn't done in single-threaded mode, so the\n\t      encoded output won't be identical to that of the multi-threaded\n\t      mode.\n\n       --flush-timeout=timeout\n\t      When compressing, if more than timeout milliseconds (a positive\n\t      integer) has passed since the previous flush and reading more\n\t      input would block, all the pending input data is flushed from\n\t      the encoder and made available in the output stream.  This can\n\t      be useful if xz is used to compress data that is streamed over a\n\t      network.\tSmall timeout values make the data available at the\n\t      receiving end with a small delay, but large timeout values give\n\t      better compression ratio.\n\n\n\t      This feature is disabled by default.  If this option is\n\t      specified more than once, the last one takes effect.  The\n\t      special timeout value of 0 can be used to explicitly disable\n\t      this feature.\n\n\n\t      This feature is not available on non-POSIX systems.\n\n\n\t      This feature is still experimental.  Currently xz is unsuitable\n\t      for decompressing the stream in real time due to how xz does\n\t      buffering.\n\n       --no-sync\n\t      Do not synchronize the target file and its directory to the\n\t      storage device before removing the source file.  This can\n\t      improve performance if compressing or decompressing many small\n\t      files.  However, if the system crashes soon after the deletion,\n\t      it is possible that the target file was not written to the\n\t      storage device but the delete operation was.  In that case\n\t      neither the original source file nor the target file is\n\t      available.\n\n\n\t      This option has an effect only when xz is going to remove the\n\t      source file.  In other cases synchronization is never done.\n\n\n\t      The synchronization and --no-sync were added in xz 5.7.1alpha.\n\n       --memlimit-compress=limit\n\t      Set a memory usage limit for compression.  If this option is\n\t      specified multiple times, the last one takes effect.\n\n\n\t      If the compression settings exceed the limit, xz will attempt to\n\t      adjust the settings downwards so that the limit is no longer\n\t      exceeded and display a notice that automatic adjustment was\n\t      done.  The adjustments are done in this order: reducing the\n\t      number of threads, switching to single-threaded mode if even one\n\t      thread in multi-threaded mode exceeds the limit, and finally\n\t      reducing the LZMA2 dictionary size.\n\n\n\t      When compressing with --format=raw or if --no-adjust has been\n\t      specified, only the number of threads may be reduced since it\n\t      can be done without affecting the compressed output.\n\n\n\t      If the limit cannot be met even with the adjustments described\n\t      above, an error is displayed and xz will exit with exit status\n\t      1.\n\n\n\t      The limit can be specified in multiple ways:\n\n\t      •  The limit can be an absolute value in bytes.  Using an",
        "\t      •  The limit can be specified as a percentage of total physical",
        "\t      •  The limit can be reset back to its default value by setting",
        "\t      For 32-bit xz there is a special case: if the limit would be\n\t      over 4020 MiB, the limit is set to 4020 MiB.  On MIPS32 2000 MiB\n\t      is used instead.\t(The values 0 and max aren't affected by this.\n\t      A similar feature doesn't exist for decompression.)  This can be\n\t      helpful when a 32-bit executable has access to 4 GiB address\n\t      space (2 GiB on MIPS32) while hopefully doing no harm in other\n\t      situations.\n\n\n\t      See also the section Memory usage.\n\n       --memlimit-decompress=limit\n\t      Set a memory usage limit for decompression.  This also affects\n\t      the --list mode.\tIf the operation is not possible without\n\t      exceeding the limit, xz will display an error and decompressing\n\t      the file will fail.  See --memlimit-compress=limit for possible\n\t      ways to specify the limit.\n\n       --memlimit-mt-decompress=limit\n\t      Set a memory usage limit for multi-threaded decompression.  This\n\t      can only affect the number of threads; this will never make xz\n\t      refuse to decompress a file.  If limit is too low to allow any\n\t      multi-threading, the limit is ignored and xz will continue in\n\t      single-threaded mode.  Note that if also --memlimit-decompress\n\t      is used, it will always apply to both single-threaded and multi-\n\t      threaded modes, and so the effective limit for multi-threading\n\t      will never be higher than the limit set with\n\t      --memlimit-decompress.\n\n\n\t      In contrast to the other memory usage limit options,\n\t      --memlimit-mt-decompress=limit has a system-specific default\n\t      limit.  xz --info-memory can be used to see the current value.\n\n\n\t      This option and its default value exist because without any\n\t      limit the threaded decompressor could end up allocating an\n\t      insane amount of memory with some input files.  If the default\n\t      limit is too low on your system, feel free to increase the limit\n\t      but never set it to a value larger than the amount of usable RAM\n\t      as with appropriate input files xz will attempt to use that\n\t      amount of memory even with a low number of threads.  Running out\n\t      of memory or swapping will not improve decompression\n\t      performance.\n\n\n\t      See --memlimit-compress=limit for possible ways to specify the\n\t      limit.  Setting limit to 0 resets the limit to the default\n\t      system-specific value.\n\n       -M limit, --memlimit=limit, --memory=limit\n\t      This is equivalent to specifying --memlimit-compress=limit\n\t      --memlimit-decompress=limit --memlimit-mt-decompress=limit.\n\n       --no-adjust\n\t      Display an error and exit if the memory usage limit cannot be\n\t      met without adjusting settings that affect the compressed\n\t      output.  That is, this prevents xz from switching the encoder\n\t      from multi-threaded mode to single-threaded mode and from\n\t      reducing the LZMA2 dictionary size.  Even when this option is\n\t      used the number of threads may be reduced to meet the memory\n\t      usage limit as that won't affect the compressed output.\n\n\n\t      Automatic adjusting is always disabled when creating raw streams\n\t      (--format=raw).\n\n       -T threads, --threads=threads\n\t      Specify the number of worker threads to use.  Setting threads to\n\t      a special value 0 makes xz use up to as many threads as the\n\t      processor(s) on the system support.  The actual number of\n\t      threads can be fewer than threads if the input file is not big\n\t      enough for threading with the given settings or if using more\n\t      threads would exceed the memory usage limit.\n\n\n\t      The single-threaded and multi-threaded compressors produce\n\t      different output.  Single-threaded compressor will give the\n\t      smallest file size but only the output from the multi-threaded\n\t      compressor can be decompressed using multiple threads.  Setting\n\t      threads to 1 will use the single-threaded mode.  Setting threads\n\t      to any other value, including 0, will use the multi-threaded\n\t      compressor even if the system supports only one hardware thread.\n\t      (xz 5.2.x used single-threaded mode in this situation.)\n\n\n\t      To use multi-threaded mode with only one thread, set threads to\n\t      +1.  The + prefix has no effect with values other than 1.  A\n\t      memory usage limit can still make xz switch to single-threaded\n\t      mode unless --no-adjust is used.\tSupport for the + prefix was\n\t      added in xz 5.4.0.\n\n\n\t      If an automatic number of threads has been requested and no\n\t      memory usage limit has been specified, then a system-specific\n\t      default soft limit will be used to possibly limit the number of\n\t      threads.\tIt is a soft limit in sense that it is ignored if the\n\t      number of threads becomes one, thus a soft limit will never stop\n\t      xz from compressing or decompressing.  This default soft limit\n\t      will not make xz switch from multi-threaded mode to single-\n\t      threaded mode.  The active limits can be seen with xz\n\t      --info-memory.\n\n\n\t      Currently the only threading method is to split the input into\n\t      blocks and compress them independently from each other.  The\n\t      default block size depends on the compression level and can be\n\t      overridden with the --block-size=size option.\n\n\n\t      Threaded decompression only works on files that contain multiple\n\t      blocks with size information in block headers.  All large enough\n\t      files compressed in multi-threaded mode meet this condition, but\n\t      files compressed in single-threaded mode don't even if\n\t      --block-size=size has been used.\n\n\n\t      The default value for threads is 0.  In xz 5.4.x and older the\n\t      default is 1.\n",
        "       A custom filter chain allows specifying the compression settings in\n       detail instead of relying on the settings associated to the presets.\n       When a custom filter chain is specified, preset options (-0 ... -9 and\n       --extreme) earlier on the command line are forgotten.  If a preset\n       option is specified after one or more custom filter chain options, the\n       new preset takes effect and the custom filter chain options specified\n       earlier are forgotten.\n\n       A filter chain is comparable to piping on the command line.  When\n       compressing, the uncompressed input goes to the first filter, whose\n       output goes to the next filter (if any).  The output of the last filter\n       gets written to the compressed file.  The maximum number of filters in\n       the chain is four, but typically a filter chain has only one or two\n       filters.\n\n       Many filters have limitations on where they can be in the filter chain:\n       some filters can work only as the last filter in the chain, some only\n       as a non-last filter, and some work in any position in the chain.\n       Depending on the filter, this limitation is either inherent to the\n       filter design or exists to prevent security issues.\n\n       A custom filter chain can be specified in two different ways.  The\n       options --filters=filters and --filters1=filters ... --filters9=filters\n       allow specifying an entire filter chain in one option using the liblzma\n       filter string syntax.  Alternatively, a filter chain can be specified\n       by using one or more individual filter options in the order they are\n       wanted in the filter chain.  That is, the order of the individual\n       filter options is significant!  When decoding raw streams\n       (--format=raw), the filter chain must be specified in the same order as\n       it was specified when compressing.  Any individual filter or preset\n       options specified before the full chain option (--filters=filters) will\n       be forgotten.  Individual filters specified after the full chain option\n       will reset the filter chain.\n\n       Both the full and individual filter options take filter-specific\n       options as a comma-separated list.  Extra commas in options are\n       ignored.  Every option has a default value, so specify those you want\n       to change.\n\n       To see the whole filter chain and options, use xz -vv (that is, use\n       --verbose twice).  This works also for viewing the filter chain options\n       used by presets.\n\n       --filters=filters\n\t      Specify the full filter chain or a preset in a single option.\n\t      Each filter can be separated by spaces or two dashes (--).\n\t      filters may need to be quoted on the shell command line so it is\n\t      parsed as a single option.  To denote options, use : or =.  A\n\t      preset can be prefixed with a - and followed with zero or more\n\t      flags.  The only supported flag is e to apply the same options\n\t      as --extreme.\n\n       --filters1=filters ... --filters9=filters\n\t      Specify up to nine additional filter chains that can be used\n\t      with --block-list.\n\n\n\t      For example, when compressing an archive with executable files\n\t      followed by text files, the executable part could use a filter\n\t      chain with a BCJ filter and the text part only the LZMA2 filter.\n\n       --filters-help\n\t      Display a help message describing how to specify presets and\n\t      custom filter chains in the --filters and --filters1=filters ...\n\t      --filters9=filters options, and exit successfully.\n\n       --lzma1[=options]\n       --lzma2[=options]\n\t      Add LZMA1 or LZMA2 filter to the filter chain.  These filters\n\t      can be used only as the last filter in the chain.\n\n\n\t      LZMA1 is a legacy filter, which is supported almost solely due\n\t      to the legacy .lzma file format, which supports only LZMA1.\n\t      LZMA2 is an updated version of LZMA1 to fix some practical\n\t      issues of LZMA1.\tThe .xz format uses LZMA2 and doesn't support\n\t      LZMA1 at all.  Compression speed and ratios of LZMA1 and LZMA2\n\t      are practically the same.\n\n\n\t      LZMA1 and LZMA2 share the same set of options:\n\n\t      preset=preset\n\t\t     Reset all LZMA1 or LZMA2 options to preset.  Preset\n\t\t     consist of an integer, which may be followed by single-\n\t\t     letter preset modifiers.  The integer can be from 0 to 9,\n\t\t     matching the command line options -0 ... -9.  The only\n\t\t     supported modifier is currently e, which matches\n\t\t     --extreme.  If no preset is specified, the default values\n\t\t     of LZMA1 or LZMA2 options are taken from the preset 6.\n\n\t      dict=size\n\t\t     Dictionary (history buffer) size indicates how many bytes\n\t\t     of the recently processed uncompressed data is kept in\n\t\t     memory.  The algorithm tries to find repeating byte\n\t\t     sequences (matches) in the uncompressed data, and replace\n\t\t     them with references to the data currently in the\n\t\t     dictionary.  The bigger the dictionary, the higher is the\n\t\t     chance to find a match.  Thus, increasing dictionary size\n\t\t     usually improves compression ratio, but a dictionary\n\t\t     bigger than the uncompressed file is waste of memory.\n\n\n\t\t     Typical dictionary size is from 64 KiB to 64 MiB.\tThe\n\t\t     minimum is 4 KiB.\tThe maximum for compression is\n\t\t     currently 1.5 GiB (1536 MiB).  The decompressor already\n\t\t     supports dictionaries up to one byte less than 4 GiB,\n\t\t     which is the maximum for the LZMA1 and LZMA2 stream\n\t\t     formats.\n\n\n\t\t     Dictionary size and match finder (mf) together determine\n\t\t     the memory usage of the LZMA1 or LZMA2 encoder.  The same\n\t\t     (or bigger) dictionary size is required for decompressing\n\t\t     that was used when compressing, thus the memory usage of\n\t\t     the decoder is determined by the dictionary size used\n\t\t     when compressing.\tThe .xz headers store the dictionary\n\t\t     size either as 2^n or 2^n + 2^(n-1), so these sizes are\n\t\t     somewhat preferred for compression.  Other sizes will get\n\t\t     rounded up when stored in the .xz headers.\n\n\t      lc=lc  Specify the number of literal context bits.  The minimum\n\t\t     is 0 and the maximum is 4; the default is 3.  In\n\t\t     addition, the sum of lc and lp must not exceed 4.\n\n\n\t\t     All bytes that cannot be encoded as matches are encoded\n\t\t     as literals.  That is, literals are simply 8-bit bytes\n\t\t     that are encoded one at a time.\n\n\n\t\t     The literal coding makes an assumption that the highest\n\t\t     lc bits of the previous uncompressed byte correlate with\n\t\t     the next byte.  For example, in typical English text, an\n\t\t     upper-case letter is often followed by a lower-case\n\t\t     letter, and a lower-case letter is usually followed by\n\t\t     another lower-case letter.  In the US-ASCII character\n\t\t     set, the highest three bits are 010 for upper-case\n\t\t     letters and 011 for lower-case letters.  When lc is at\n\t\t     least 3, the literal coding can take advantage of this\n\t\t     property in the uncompressed data.\n\n\n\t\t     The default value (3) is usually good.  If you want\n\t\t     maximum compression, test lc=4.  Sometimes it helps a\n\t\t     little, and sometimes it makes compression worse.\tIf it\n\t\t     makes it worse, test lc=2 too.\n\n\t      lp=lp  Specify the number of literal position bits.  The minimum\n\t\t     is 0 and the maximum is 4; the default is 0.\n\n\n\t\t     Lp affects what kind of alignment in the uncompressed\n\t\t     data is assumed when encoding literals.  See pb below for\n\t\t     more information about alignment.\n\n\t      pb=pb  Specify the number of position bits.  The minimum is 0\n\t\t     and the maximum is 4; the default is 2.\n\n\n\t\t     Pb affects what kind of alignment in the uncompressed\n\t\t     data is assumed in general.  The default means four-byte\n\t\t     alignment (2^pb=2^2=4), which is often a good choice when\n\t\t     there's no better guess.\n\n\n\t\t     When the alignment is known, setting pb accordingly may\n\t\t     reduce the file size a little.  For example, with text\n\t\t     files having one-byte alignment (US-ASCII, ISO-8859-*,\n\t\t     UTF-8), setting pb=0 can improve compression slightly.\n\t\t     For UTF-16 text, pb=1 is a good choice.  If the alignment\n\t\t     is an odd number like 3 bytes, pb=0 might be the best\n\t\t     choice.\n\n\n\t\t     Even though the assumed alignment can be adjusted with pb\n\t\t     and lp, LZMA1 and LZMA2 still slightly favor 16-byte\n\t\t     alignment.  It might be worth taking into account when\n\t\t     designing file formats that are likely to be often\n\t\t     compressed with LZMA1 or LZMA2.\n\n\t      mf=mf  Match finder has a major effect on encoder speed, memory\n\t\t     usage, and compression ratio.  Usually Hash Chain match\n\t\t     finders are faster than Binary Tree match finders.  The\n\t\t     default depends on the preset: 0 uses hc3, 1–3 use hc4,\n\t\t     and the rest use bt4.\n\n\n\t\t     The following match finders are supported.  The memory\n\t\t     usage formulas below are rough approximations, which are\n\t\t     closest to the reality when dict is a power of two.\n\n\t\t     hc3    Hash Chain with 2- and 3-byte hashing\n\t\t\t    Minimum value for nice: 3\n\t\t\t    Memory usage:\n\t\t\t    dict * 7.5 (if dict <= 16 MiB);\n\t\t\t    dict * 5.5 + 64 MiB (if dict > 16 MiB)\n\n\t\t     hc4    Hash Chain with 2-, 3-, and 4-byte hashing\n\t\t\t    Minimum value for nice: 4\n\t\t\t    Memory usage:\n\t\t\t    dict * 7.5 (if dict <= 32 MiB);\n\t\t\t    dict * 6.5 (if dict > 32 MiB)\n\n\t\t     bt2    Binary Tree with 2-byte hashing\n\t\t\t    Minimum value for nice: 2\n\t\t\t    Memory usage: dict * 9.5\n\n\t\t     bt3    Binary Tree with 2- and 3-byte hashing\n\t\t\t    Minimum value for nice: 3\n\t\t\t    Memory usage:\n\t\t\t    dict * 11.5 (if dict <= 16 MiB);\n\t\t\t    dict * 9.5 + 64 MiB (if dict > 16 MiB)\n\n\t\t     bt4    Binary Tree with 2-, 3-, and 4-byte hashing\n\t\t\t    Minimum value for nice: 4\n\t\t\t    Memory usage:\n\t\t\t    dict * 11.5 (if dict <= 32 MiB);\n\t\t\t    dict * 10.5 (if dict > 32 MiB)\n\n\t      mode=mode\n\t\t     Compression mode specifies the method to analyze the data\n\t\t     produced by the match finder.  Supported modes are fast\n\t\t     and normal.  The default is fast for presets 0–3 and\n\t\t     normal for presets 4–9.\n\n\n\t\t     Usually fast is used with Hash Chain match finders and\n\t\t     normal with Binary Tree match finders.  This is also what\n\t\t     the presets do.\n\n\t      nice=nice\n\t\t     Specify what is considered to be a nice length for a\n\t\t     match.  Once a match of at least nice bytes is found, the\n\t\t     algorithm stops looking for possibly better matches.\n\n\n\t\t     Nice can be 2–273 bytes.  Higher values tend to give\n\t\t     better compression ratio at the expense of speed.\tThe\n\t\t     default depends on the preset.\n\n\t      depth=depth\n\t\t     Specify the maximum search depth in the match finder.\n\t\t     The default is the special value of 0, which makes the\n\t\t     compressor determine a reasonable depth from mf and nice.\n\n\n\t\t     Reasonable depth for Hash Chains is 4–100 and 16–1000 for\n\t\t     Binary Trees.  Using very high values for depth can make\n\t\t     the encoder extremely slow with some files.  Avoid\n\t\t     setting the depth over 1000 unless you are prepared to\n\t\t     interrupt the compression in case it is taking far too\n\t\t     long.\n\n\n\t      When decoding raw streams (--format=raw), LZMA2 needs only the\n\t      dictionary size.\tLZMA1 needs also lc, lp, and pb.\n\n       --x86[=options]\n       --arm[=options]\n       --armthumb[=options]\n       --arm64[=options]\n       --powerpc[=options]\n       --ia64[=options]\n       --sparc[=options]\n       --riscv[=options]\n\t      Add a branch/call/jump (BCJ) filter to the filter chain.\tThese\n\t      filters can be used only as a non-last filter in the filter\n\t      chain.\n\n\n\t      A BCJ filter converts relative addresses in the machine code to\n\t      their absolute counterparts.  This doesn't change the size of\n\t      the data but it increases redundancy, which can help LZMA2 to\n\t      produce 0–15 % smaller .xz file.\tThe BCJ filters are always\n\t      reversible, so using a BCJ filter for wrong type of data doesn't\n\t      cause any data loss, although it may make the compression ratio\n\t      slightly worse.  The BCJ filters are very fast and use an\n\t      insignificant amount of memory.\n\n\n\t      These BCJ filters have known problems related to the compression\n\t      ratio:\n\n\t      •  Some types of files containing executable code (for example,",
        "\t      •  If a BCJ filter is applied on an archive, it is possible that",
        "\t      Different instruction sets have different alignment: the\n\t      executable file must be aligned to a multiple of this value in\n\t      the input data to make the filter work.\n\n\t\t     Filter\t Alignment   Notes\n\t\t     x86\t     1\t     32-bit or 64-bit x86\n\t\t     ARM\t     4\n\t\t     ARM-Thumb\t     2\n\t\t     ARM64\t     4\t     4096-byte alignment is best\n\t\t     PowerPC\t     4\t     Big endian only\n\t\t     IA-64\t    16\t     Itanium\n\t\t     SPARC\t     4\n\t\t     RISC-V\t     2\n\n\n\t      Since the BCJ-filtered data is usually compressed with LZMA2,\n\t      the compression ratio may be improved slightly if the LZMA2\n\t      options are set to match the alignment of the selected BCJ\n\t      filter.  Examples:\n\n\t      •  IA-64 filter has 16-byte alignment so pb=4,lp=4,lc=0 is good",
        "\t      •  RISC-V code has 2-byte or 4-byte alignment depending on",
        "\t      •  ARM64 is always 4-byte aligned so pb=2,lp=2,lc=2 is the best.\n\n\t      •  The x86 filter is an exception.  It's usually good to stick",
        "\t      All BCJ filters support the same options:\n\n\t      start=offset\n\t\t     Specify the start offset that is used when converting\n\t\t     between relative and absolute addresses.  The offset must\n\t\t     be a multiple of the alignment of the filter (see the\n\t\t     table above).  The default is zero.  In practice, the\n\t\t     default is good; specifying a custom offset is almost\n\t\t     never useful.\n\n       --delta[=options]\n\t      Add the Delta filter to the filter chain.  The Delta filter can\n\t      be only used as a non-last filter in the filter chain.\n\n\n\t      Currently only simple byte-wise delta calculation is supported.\n\t      It can be useful when compressing, for example, uncompressed\n\t      bitmap images or uncompressed PCM audio.\tHowever, special\n\t      purpose algorithms may give significantly better results than\n\t      Delta + LZMA2.  This is true especially with audio, which\n\t      compresses faster and better, for example, with flac(1).\n\n\n\t      Supported options:\n\n\t      dist=distance\n\t\t     Specify the distance of the delta calculation in bytes.\n\t\t     distance must be 1–256.  The default is 1.\n\n\n\t\t     For example, with dist=2 and eight-byte input A1 B1 A2 B3\n\t\t     A3 B5 A4 B7, the output will be A1 B1 01 02 01 02 01 02.\n",
        "       -q, --quiet\n\t      Suppress warnings and notices.  Specify this twice to suppress\n\t      errors too.  This option has no effect on the exit status.  That\n\t      is, even if a warning was suppressed, the exit status to\n\t      indicate a warning is still used.\n\n       -v, --verbose\n\t      Be verbose.  If standard error is connected to a terminal, xz\n\t      will display a progress indicator.  Specifying --verbose twice\n\t      will give even more verbose output.\n\n\n\t      The progress indicator shows the following information:\n\n\t      •  Completion percentage is shown if the size of the input file",
        "\t      •  Amount of compressed data produced (compressing) or consumed",
        "\t      •  Amount of uncompressed data consumed (compressing) or",
        "\t      •  Compression ratio, which is calculated by dividing the amount",
        "\t      •  Compression or decompression speed.  This is measured as the",
        "\t      •  Elapsed time in the format M:SS or H:MM:SS.\n\n\t      •  Estimated remaining time is shown only when the size of the",
        "\t      When standard error is not a terminal, --verbose will make xz\n\t      print the filename, compressed size, uncompressed size,\n\t      compression ratio, and possibly also the speed and elapsed time\n\t      on a single line to standard error after compressing or\n\t      decompressing the file.  The speed and elapsed time are included\n\t      only when the operation took at least a few seconds.  If the\n\t      operation didn't finish, for example, due to user interruption,\n\t      also the completion percentage is printed if the size of the\n\t      input file is known.\n\n       -Q, --no-warn\n\t      Don't set the exit status to 2 even if a condition worth a\n\t      warning was detected.  This option doesn't affect the verbosity\n\t      level, thus both --quiet and --no-warn have to be used to not\n\t      display warnings and to not alter the exit status.\n\n       --robot\n\t      Print messages in a machine-parsable format.  This is intended\n\t      to ease writing frontends that want to use xz instead of\n\t      liblzma, which may be the case with various scripts.  The output\n\t      with this option enabled is meant to be stable across xz\n\t      releases.  See the section ROBOT MODE for details.\n\n       --info-memory\n\t      Display, in human-readable format, how much physical memory\n\t      (RAM) and how many processor threads xz thinks the system has\n\t      and the memory usage limits for compression and decompression,\n\t      and exit successfully.\n\n       -h, --help\n\t      Display a help message describing the most commonly used\n\t      options, and exit successfully.\n\n       -H, --long-help\n\t      Display a help message describing all features of xz, and exit\n\t      successfully\n\n       -V, --version\n\t      Display the version number of xz and liblzma in human readable\n\t      format.  To get machine-parsable output, specify --robot before\n\t      --version.\n",
        "       The robot mode is activated with the --robot option.  It makes the\n       output of xz easier to parse by other programs.\tCurrently --robot is\n       supported only together with --list, --filters-help, --info-memory, and\n       --version.  It will be supported for compression and decompression in\n       the future.\n",
        "       xz --robot --list uses tab-separated output.  The first column of every\n       line has a string that indicates the type of the information found on\n       that line:\n\n       name   This is always the first line when starting to list a file.  The\n\t      second column on the line is the filename.\n\n       file   This line contains overall information about the .xz file.  This\n\t      line is always printed after the name line.\n\n       stream This line type is used only when --verbose was specified.  There\n\t      are as many stream lines as there are streams in the .xz file.\n\n       block  This line type is used only when --verbose was specified.  There\n\t      are as many block lines as there are blocks in the .xz file.\n\t      The block lines are shown after all the stream lines; different\n\t      line types are not interleaved.\n\n       summary\n\t      This line type is used only when --verbose was specified twice.\n\t      This line is printed after all block lines.  Like the file line,\n\t      the summary line contains overall information about the .xz\n\t      file.\n\n       totals This line is always the very last line of the list output.  It\n\t      shows the total counts and sizes.\n\n       The columns of the file lines:\n\t      2.  Number of streams in the file\n\t      3.  Total number of blocks in the stream(s)\n\t      4.  Compressed size of the file\n\t      5.  Uncompressed size of the file\n\t      6.  Compression ratio, for example, 0.123.  If ratio is over\n\t\t  9.999, three dashes (---) are displayed instead of the\n\t\t  ratio.\n\t      7.  Comma-separated list of integrity check names.  The\n\t\t  following strings are used for the known check types: None,\n\t\t  CRC32, CRC64, and SHA-256.  For unknown check types,\n\t\t  Unknown-N is used, where N is the Check ID as a decimal\n\t\t  number (one or two digits).\n\t      8.  Total size of stream padding in the file\n\n       The columns of the stream lines:\n\t      2.  Stream number (the first stream is 1)\n\t      3.  Number of blocks in the stream\n\t      4.  Compressed start offset\n\t      5.  Uncompressed start offset\n\t      6.  Compressed size (does not include stream padding)\n\t      7.  Uncompressed size\n\t      8.  Compression ratio\n\t      9.  Name of the integrity check\n\t      10. Size of stream padding\n\n       The columns of the block lines:\n\t      2.  Number of the stream containing this block\n\t      3.  Block number relative to the beginning of the stream (the\n\t\t  first block is 1)\n\t      4.  Block number relative to the beginning of the file\n\t      5.  Compressed start offset relative to the beginning of the\n\t\t  file\n\t      6.  Uncompressed start offset relative to the beginning of the\n\t\t  file\n\t      7.  Total compressed size of the block (includes headers)\n\t      8.  Uncompressed size\n\t      9.  Compression ratio\n\t      10. Name of the integrity check\n\n       If --verbose was specified twice, additional columns are included on\n       the block lines.  These are not displayed with a single --verbose,\n       because getting this information requires many seeks and can thus be\n       slow:\n\t      11. Value of the integrity check in hexadecimal\n\t      12. Block header size\n\t      13. Block flags: c indicates that compressed size is present,\n\t\t  and u indicates that uncompressed size is present.  If the\n\t\t  flag is not set, a dash (-) is shown instead to keep the\n\t\t  string length fixed.\tNew flags may be added to the end of\n\t\t  the string in the future.\n\t      14. Size of the actual compressed data in the block (this\n\t\t  excludes the block header, block padding, and check fields)\n\t      15. Amount of memory (in bytes) required to decompress this\n\t\t  block with this xz version\n\t      16. Filter chain.  Note that most of the options used at\n\t\t  compression time cannot be known, because only the options\n\t\t  that are needed for decompression are stored in the .xz\n\t\t  headers.\n\n       The columns of the summary lines:\n\t      2.  Amount of memory (in bytes) required to decompress this file\n\t\t  with this xz version\n\t      3.  yes or no indicating if all block headers have both\n\t\t  compressed size and uncompressed size stored in them\n\t      Since xz 5.1.2alpha:\n\t      4.  Minimum xz version required to decompress the file\n\n       The columns of the totals line:\n\t      2.  Number of streams\n\t      3.  Number of blocks\n\t      4.  Compressed size\n\t      5.  Uncompressed size\n\t      6.  Average compression ratio\n\t      7.  Comma-separated list of integrity check names that were\n\t\t  present in the files\n\t      8.  Stream padding size\n\t      9.  Number of files.  This is here to keep the order of the\n\t\t  earlier columns the same as on file lines.\n\n       If --verbose was specified twice, additional columns are included on\n       the totals line:\n\t      10. Maximum amount of memory (in bytes) required to decompress\n\t\t  the files with this xz version\n\t      11. yes or no indicating if all block headers have both\n\t\t  compressed size and uncompressed size stored in them\n\t      Since xz 5.1.2alpha:\n\t      12. Minimum xz version required to decompress the file\n\n       Future versions may add new line types and new columns can be added to\n       the existing line types, but the existing columns won't be changed.\n",
        "       xz --robot --filters-help prints the supported filters in the following\n       format:\n\n       filter:option=<value>,option=<value>...\n\n       filter Name of the filter\n\n       option Name of a filter specific option\n\n       value  Numeric value ranges appear as <min-max>.  String value choices\n\t      are shown within < > and separated by a | character.\n\n       Each filter is printed on its own line.\n",
        "       xz --robot --info-memory prints a single line with multiple tab-\n       separated columns:\n\n       1.  Total amount of physical memory (RAM) in bytes.\n\n       2.  Memory usage limit for compression in bytes (--memlimit-compress).\n\t   A special value of 0 indicates the default setting which for\n\t   single-threaded mode is the same as no limit.\n\n       3.  Memory usage limit for decompression in bytes\n\t   (--memlimit-decompress).  A special value of 0 indicates the\n\t   default setting which for single-threaded mode is the same as no\n\t   limit.\n\n       4.  Since xz 5.3.4alpha: Memory usage for multi-threaded decompression\n\t   in bytes (--memlimit-mt-decompress).  This is never zero because a\n\t   system-specific default value shown in the column 5 is used if no\n\t   limit has been specified explicitly.  This is also never greater\n\t   than the value in the column 3 even if a larger value has been\n\t   specified with --memlimit-mt-decompress.\n\n       5.  Since xz 5.3.4alpha: A system-specific default memory usage limit\n\t   that is used to limit the number of threads when compressing with\n\t   an automatic number of threads (--threads=0) and no memory usage\n\t   limit has been specified (--memlimit-compress).  This is also used\n\t   as the default value for --memlimit-mt-decompress.\n\n       6.  Since xz 5.3.4alpha: Number of available processor threads.\n\n       In the future, the output of xz --robot --info-memory may have more\n       columns, but never more than a single line.\n",
        "       xz --robot --version prints the version number of xz and liblzma in the\n       following format:\n\n       XZ_VERSION=XYYYZZZS\n       LIBLZMA_VERSION=XYYYZZZS\n\n       X      Major version.\n\n       YYY    Minor version.  Even numbers are stable.\tOdd numbers are alpha\n\t      or beta versions.\n\n       ZZZ    Patch level for stable releases or just a counter for\n\t      development releases.\n\n       S      Stability.  0 is alpha, 1 is beta, and 2 is stable.  S should be\n\t      always 2 when YYY is even.\n\n       XYYYZZZS are the same on both lines if xz and liblzma are from the same\n       XZ Utils release.\n\n       Examples: 4.999.9beta is 49990091 and 5.0.0 is 50000002.\n",
        "       0      All is good.\n\n       1      An error occurred.\n\n       2      Something worth a warning occurred, but no actual errors\n\t      occurred.\n\n       Notices (not warnings or errors) printed on standard error don't affect\n       the exit status.\n",
        "       xz parses space-separated lists of options from the environment\n       variables XZ_DEFAULTS and XZ_OPT, in this order, before parsing the\n       options from the command line.  Note that only options are parsed from\n       the environment variables; all non-options are silently ignored.\n       Parsing is done with getopt_long(3) which is used also for the command\n       line arguments.\n\n       Warning: By setting these environment variables, one is effectively\n       modifying programs and scripts that run xz.  Most of the time it is\n       safe to set memory usage limits, number of threads, and compression\n       options via the environment variables.  However, some options can break\n       scripts.  An obvious example is --help which makes xz show the help\n       text instead of compressing or decompressing a file.  More subtle\n       examples are --quiet and --verbose.  In many cases it works well to\n       enable the progress indicator using --verbose, but in some situations\n       the extra messages create problems.  The verbosity level also affects\n       the behavior of --list.\n\n       XZ_DEFAULTS\n\t      User-specific or system-wide default options.  Typically this is\n\t      set in a shell initialization script to enable xz's memory usage\n\t      limiter by default or set the default number of threads.\n\t      Excluding shell initialization scripts and similar special\n\t      cases, scripts should never set or unset XZ_DEFAULTS.\n\n       XZ_OPT This is for passing options to xz when it is not possible to set\n\t      the options directly on the xz command line.  This is the case\n\t      when xz is run by a script or tool, for example, GNU tar(1):\n\n\t\t     XZ_OPT=-2v tar caf foo.tar.xz foo\n\n\n\t      Scripts may use XZ_OPT, for example, to set script-specific\n\t      default compression options.  It is still recommended to allow\n\t      users to override XZ_OPT if that is reasonable.  For example, in\n\t      sh(1) scripts one may use something like this:\n\n\t\t     XZ_OPT=${XZ_OPT-\"-7e\"}\n\t\t     export XZ_OPT\n",
        "       The command line syntax of xz is practically a superset of lzma,\n       unlzma, and lzcat as found from LZMA Utils 4.32.x.  In most cases, it\n       is possible to replace LZMA Utils with XZ Utils without breaking\n       existing scripts.  There are some incompatibilities though, which may\n       sometimes cause problems.\n",
        "       The numbering of the compression level presets is not identical in xz\n       and LZMA Utils.\tThe most important difference is how dictionary sizes\n       are mapped to different presets.  Dictionary size is roughly equal to\n       the decompressor memory usage.\n\n\t      Level\txz\tLZMA Utils\n\t       -0     256 KiB\t   N/A\n\t       -1\t1 MiB\t  64 KiB\n\t       -2\t2 MiB\t   1 MiB\n\t       -3\t4 MiB\t 512 KiB\n\t       -4\t4 MiB\t   1 MiB\n\t       -5\t8 MiB\t   2 MiB\n\t       -6\t8 MiB\t   4 MiB\n\t       -7      16 MiB\t   8 MiB\n\t       -8      32 MiB\t  16 MiB\n\t       -9      64 MiB\t  32 MiB\n\n       The dictionary size differences affect the compressor memory usage too,\n       but there are some other differences between LZMA Utils and XZ Utils,\n       which make the difference even bigger:\n\n\t      Level\txz\tLZMA Utils 4.32.x\n\t       -0\t3 MiB\t       N/A\n\t       -1\t9 MiB\t       2 MiB\n\t       -2      17 MiB\t      12 MiB\n\t       -3      32 MiB\t      12 MiB\n\t       -4      48 MiB\t      16 MiB\n\t       -5      94 MiB\t      26 MiB\n\t       -6      94 MiB\t      45 MiB\n\t       -7     186 MiB\t      83 MiB\n\t       -8     370 MiB\t     159 MiB\n\t       -9     674 MiB\t     311 MiB\n\n       The default preset level in LZMA Utils is -7 while in XZ Utils it is\n       -6, so both use an 8 MiB dictionary by default.\n",
        "       The uncompressed size of the file can be stored in the .lzma header.\n       LZMA Utils does that when compressing regular files.  The alternative\n       is to mark that uncompressed size is unknown and use end-of-payload\n       marker to indicate where the decompressor should stop.  LZMA Utils uses\n       this method when uncompressed size isn't known, which is the case, for\n       example, in pipes.\n\n       xz supports decompressing .lzma files with or without end-of-payload\n       marker, but all .lzma files created by xz will use end-of-payload\n       marker and have uncompressed size marked as unknown in the .lzma\n       header.\tThis may be a problem in some uncommon situations.  For\n       example, a .lzma decompressor in an embedded device might work only\n       with files that have known uncompressed size.  If you hit this problem,\n       you need to use LZMA Utils or LZMA SDK to create .lzma files with known\n       uncompressed size.\n",
        "       The .lzma format allows lc values up to 8, and lp values up to 4.  LZMA\n       Utils can decompress files with any lc and lp, but always creates files\n       with lc=3 and lp=0.  Creating files with other lc and lp is possible\n       with xz and with LZMA SDK.\n\n       The implementation of the LZMA1 filter in liblzma requires that the sum\n       of lc and lp must not exceed 4.\tThus, .lzma files, which exceed this\n       limitation, cannot be decompressed with xz.\n\n       LZMA Utils creates only .lzma files which have a dictionary size of 2^n\n       (a power of 2) but accepts files with any dictionary size.  liblzma\n       accepts only .lzma files which have a dictionary size of 2^n or 2^n +\n       2^(n-1).  This is to decrease false positives when detecting .lzma\n       files.\n\n       These limitations shouldn't be a problem in practice, since practically\n       all .lzma files have been compressed with settings that liblzma will\n       accept.\n",
        "       When decompressing, LZMA Utils silently ignore everything after the\n       first .lzma stream.  In most situations, this is a bug.\tThis also\n       means that LZMA Utils don't support decompressing concatenated .lzma\n       files.\n\n       If there is data left after the first .lzma stream, xz considers the\n       file to be corrupt unless --single-stream was used.  This may break\n       obscure scripts which have assumed that trailing garbage is ignored.\n",
        "       The exact compressed output produced from the same uncompressed input\n       file may vary between XZ Utils versions even if compression options are\n       identical.  This is because the encoder can be improved (faster or\n       better compression) without affecting the file format.  The output can\n       vary even between different builds of the same XZ Utils version, if\n       different build options are used.\n\n       The above means that once --rsyncable has been implemented, the\n       resulting files won't necessarily be rsyncable unless both old and new\n       files have been compressed with the same xz version.  This problem can\n       be fixed if a part of the encoder implementation is frozen to keep\n       rsyncable output stable across xz versions.\n",
        "       Embedded .xz decompressor implementations like XZ Embedded don't\n       necessarily support files created with integrity check types other than\n       none and crc32.\tSince the default is --check=crc64, you must use\n       --check=none or --check=crc32 when creating files for embedded systems.\n\n       Outside embedded systems, all .xz format decompressors support all the\n       check types, or at least are able to decompress the file without\n       verifying the integrity check if the particular check is not supported.\n\n       XZ Embedded supports BCJ filters, but only with the default start\n       offset.\n",
        "       Compress the file foo into foo.xz using the default compression level\n       (-6), and remove foo if compression is successful:\n\n\t      xz foo\n\n       Decompress bar.xz into bar and don't remove bar.xz even if\n       decompression is successful:\n\n\t      xz -dk bar.xz\n\n       Create baz.tar.xz with the preset -4e (-4 --extreme), which is slower\n       than the default -6, but needs less memory for compression and\n       decompression (48 MiB and 5 MiB, respectively):\n\n\t      tar cf - baz | xz -4e > baz.tar.xz\n\n       A mix of compressed and uncompressed files can be decompressed to\n       standard output with a single command:\n\n\t      xz -dcf a.txt b.txt.xz c.txt d.txt.lzma > abcd.txt\n",
        "       On GNU and *BSD, find(1) and xargs(1) can be used to parallelize\n       compression of many files:\n\n\t      find . -type f \\! -name '*.xz' -print0 \\\n\t\t  | xargs -0r -P4 -n16 xz -T1\n\n       The -P option to xargs(1) sets the number of parallel xz processes.\n       The best value for the -n option depends on how many files there are to\n       be compressed.  If there are only a couple of files, the value should\n       probably be 1; with tens of thousands of files, 100 or even more may be\n       appropriate to reduce the number of xz processes that xargs(1) will\n       eventually create.\n\n       The option -T1 for xz is there to force it to single-threaded mode,\n       because xargs(1) is used to control the amount of parallelization.\n",
        "       Calculate how many bytes have been saved in total after compressing\n       multiple files:\n\n\t      xz --robot --list *.xz | awk '/^totals/{print $5-$4}'\n\n       A script may want to know that it is using new enough xz.  The\n       following sh(1) script checks that the version number of the xz tool is\n       at least 5.0.0.\tThis method is compatible with old beta versions,\n       which didn't support the --robot option:\n\n\t      if ! eval \"$(xz --robot --version 2> /dev/null)\" ||\n\t\t      [ \"$XZ_VERSION\" -lt 50000002 ]; then\n\t\t  echo \"Your xz is too old.\"\n\t      fi\n\t      unset XZ_VERSION LIBLZMA_VERSION\n\n       Set a memory usage limit for decompression using XZ_OPT, but if a limit\n       has already been set, don't increase it:\n\n\t      NEWLIM=$((123 << 20))  # 123 MiB\n\t      OLDLIM=$(xz --robot --info-memory | cut -f3)\n\t      if [ $OLDLIM -eq 0 -o $OLDLIM -gt $NEWLIM ]; then\n\t\t  XZ_OPT=\"$XZ_OPT --memlimit-decompress=$NEWLIM\"\n\t\t  export XZ_OPT\n\t      fi\n",
        "       The simplest use for custom filter chains is customizing a LZMA2\n       preset.\tThis can be useful, because the presets cover only a subset of\n       the potentially useful combinations of compression settings.\n\n       The CompCPU columns of the tables from the descriptions of the options\n       -0 ... -9 and --extreme are useful when customizing LZMA2 presets.\n       Here are the relevant parts collected from those two tables:\n\n\t      Preset   CompCPU\n\t       -0\t  0\n\t       -1\t  1\n\t       -2\t  2\n\t       -3\t  3\n\t       -4\t  4\n\t       -5\t  5\n\t       -6\t  6\n\t       -5e\t  7\n\t       -6e\t  8\n\n       If you know that a file requires somewhat big dictionary (for example,\n       32 MiB) to compress well, but you want to compress it quicker than xz\n       -8 would do, a preset with a low CompCPU value (for example, 1) can be\n       modified to use a bigger dictionary:\n\n\t      xz --lzma2=preset=1,dict=32MiB foo.tar\n\n       With certain files, the above command may be faster than xz -6 while\n       compressing significantly better.  However, it must be emphasized that\n       only some files benefit from a big dictionary while keeping the CompCPU\n       value low.  The most obvious situation, where a big dictionary can help\n       a lot, is an archive containing very similar files of at least a few\n       megabytes each.\tThe dictionary size has to be significantly bigger\n       than any individual file to allow LZMA2 to take full advantage of the\n       similarities between consecutive files.\n\n       If very high compressor and decompressor memory usage is fine, and the\n       file being compressed is at least several hundred megabytes, it may be\n       useful to use an even bigger dictionary than the 64 MiB that xz -9\n       would use:\n\n\t      xz -vv --lzma2=dict=192MiB big_foo.tar\n\n       Using -vv (--verbose --verbose) like in the above example can be useful\n       to see the memory requirements of the compressor and decompressor.\n       Remember that using a dictionary bigger than the size of the\n       uncompressed file is waste of memory, so the above command isn't useful\n       for small files.\n\n       Sometimes the compression time doesn't matter, but the decompressor\n       memory usage has to be kept low, for example, to make it possible to\n       decompress the file on an embedded system.  The following command uses\n       -6e (-6 --extreme) as a base and sets the dictionary to only 64 KiB.\n       The resulting file can be decompressed with XZ Embedded (that's why\n       there is --check=crc32) using about 100 KiB of memory.\n\n\t      xz --check=crc32 --lzma2=preset=6e,dict=64KiB foo\n\n       If you want to squeeze out as many bytes as possible, adjusting the\n       number of literal context bits (lc) and number of position bits (pb)\n       can sometimes help.  Adjusting the number of literal position bits (lp)\n       might help too, but usually lc and pb are more important.  For example,\n       a source code archive contains mostly US-ASCII text, so something like\n       the following might give slightly (like 0.1 %) smaller file than xz -6e\n       (try also without lc=4):\n\n\t      xz --lzma2=preset=6e,pb=0,lc=4 source_code.tar\n\n       Using another filter together with LZMA2 can improve compression with\n       certain file types.  For example, to compress a x86-32 or x86-64 shared\n       library using the x86 BCJ filter:\n\n\t      xz --x86 --lzma2 libfoo.so\n\n       Note that the order of the filter options is significant.  If --x86 is\n       specified after --lzma2, xz will give an error, because there cannot be\n       any filter after LZMA2, and also because the x86 BCJ filter cannot be\n       used as the last filter in the chain.\n\n       The Delta filter together with LZMA2 can give good results with bitmap\n       images.\tIt should usually beat PNG, which has a few more advanced\n       filters than simple delta but uses Deflate for the actual compression.\n\n       The image has to be saved in uncompressed format, for example, as\n       uncompressed TIFF.  The distance parameter of the Delta filter is set\n       to match the number of bytes per pixel in the image.  For example,\n       24-bit RGB bitmap needs dist=3, and it is also good to pass pb=0 to\n       LZMA2 to accommodate the three-byte alignment:\n\n\t      xz --delta=dist=3 --lzma2=pb=0 foo.tiff\n\n       If multiple images have been put into a single archive (for example,\n       .tar), the Delta filter will work on that too as long as all images\n       have the same number of bytes per pixel.\n",
        "       xzdec(1), xzdiff(1), xzgrep(1), xzless(1), xzmore(1), gzip(1),\n       bzip2(1), 7z(1)\n\n       XZ Utils: <https://tukaani.org/xz/>\n       XZ Embedded: <https://tukaani.org/xz/embedded.html>\n       LZMA SDK: <https://7-zip.org/sdk.html>\n"
      ]
    }
  ],
  "flags": [
    {
      "flag": "--format",
      "description": " the limit is very small.  The scaling of the settings is done in steps that don't match the compression level presets, for example, if the limit is only slightly less than the amount required for xz -9, the settings will be scaled down only a little, not all the way down to xz",
      "optional": false
    },
    {
      "flag": "-8",
      "description": ". Concatenation and padding with .xz files It is possible to concatenate .xz files as is.  xz will decompress such files as if they were a single .xz file. It is possible to insert padding between the concatenated parts or after the last part.  The padding must consist of null bytes and the size of the padding must be a multiple of four bytes.  This can be useful, for example, if the .xz file is stored on a medium that measures file sizes in 512-byte blocks. Concatenation and padding are not allowed with .lzma files or raw streams."
    }
  ],
  "examples": [],
  "relatedCommands": [
    "flac",
    "unxz",
    "xzcat",
    "lzma",
    "unlzma",
    "lzcat",
    "decompress",
    "option",
    "equivalent",
    "stdout",
    "format",
    "writing",
    "scripts",
    "need",
    "recommended"
  ],
  "seeAlso": [
    {
      "name": "flac",
      "section": 1
    }
  ],
  "metadata": {},
  "searchContent": "xz xz manual page xz is a general-purpose data compression tool with command line syntax similar to gzip 1 and bzip2 1 xz option file command aliases unxz is equivalent to xz --decompress xzcat is equivalent to xz --decompress --stdout lzma is equivalent to xz --format lzma unlzma is equivalent to xz --format lzma --decompress lzcat is equivalent to xz --format lzma --decompress --stdout when writing scripts that need to decompress files it is recommended to always use the name xz with appropriate arguments xz -d or xz -dc instead of the names unxz and xzcat xz manual page general-purpose data compression tool command line syntax similar gzip 1 bzip2 1 --format the limit is very small the scaling of the settings is done in steps that don t match the compression level presets for example if the limit is only slightly less than the amount required for xz -9 the settings will be scaled down only a little not all the way down to xz -8 concatenation and padding with xz files it is possible to concatenate xz files as is xz will decompress such files as if they were a single xz file it is possible to insert padding between the concatenated parts or after the last part the padding must consist of null bytes and the size of the padding must be a multiple of four bytes this can be useful for example if the xz file is stored on a medium that measures file sizes in 512-byte blocks concatenation and padding are not allowed with lzma files or raw streams name tukaani 2025-03-08 xz 1",
  "keywords": [
    "xz",
    "manual",
    "page",
    "general-purpose",
    "data",
    "compression",
    "tool",
    "command",
    "line",
    "syntax",
    "similar",
    "gzip(1)",
    "bzip2(1)."
  ],
  "complexity": "basic",
  "hash": "3f03bb8599a43d4d",
  "parsedAt": "2025-06-17T19:32:24.573Z",
  "parseVersion": "2.0.0",
  "isCommon": false,
  "hasInteractiveExamples": false,
  "hasDiagrams": false
}