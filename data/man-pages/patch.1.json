{
  "name": "patch",
  "section": 1,
  "title": "patch manual page",
  "description": "patch will take a patch file containing any of the four forms of difference listing produced by the diff(1) program and apply those differences to an original file, producing a patched version.",
  "synopsis": "patch [-bCcEeflNnRstuv] [-B backup-prefix] [-D symbol] [-d directory] [-g vcs-option] [-F max-fuzz] [-i patchfile] [-o out-file] [-p strip-count] [-r rej-name] [-T | -Z] [-V t | nil | never | none] [-x number] [-Y prefix] [-z backup-ext] [--quoting-style style] [--posix] [origfile [patchfile]] patch <patchfile",
  "category": "User Commands",
  "sections": [
    {
      "id": "name",
      "title": "NAME",
      "content": "macOS 15.5\t\t\tApril 27, 2022\t\t\t    macOS 15.5",
      "level": 1,
      "subsections": [],
      "codeBlocks": [
        "     patch – apply a diff file to an original\n",
        "     patch [-bCcEeflNnRstuv] [-B backup-prefix] [-D symbol] [-d directory]\n\t   [-g vcs-option] [-F max-fuzz] [-i patchfile] [-o out-file]\n\t   [-p strip-count] [-r rej-name] [-T | -Z]\n\t   [-V t | nil | never | none] [-x number] [-Y prefix] [-z backup-ext]\n\t   [--quoting-style style] [--posix] [origfile [patchfile]]\n     patch <patchfile\n",
        "     patch will take a patch file containing any of the four forms of\n     difference listing produced by the diff(1) program and apply those\n     differences to an original file, producing a patched version.  If\n     patchfile is omitted, or is a hyphen, the patch will be read from the\n     standard input.\n\n     patch will attempt to determine the type of the diff listing, unless\n     overruled by a -c, -e, -n, or -u option.  Context diffs (old-style, new-\n     style, and unified) and normal diffs are applied directly by the patch\n     program itself, whereas ed diffs are simply fed to the ed(1) editor via a\n     pipe.\n\n     If the patchfile contains more than one patch, patch will try to apply\n     each of them as if they came from separate patch files.  This means,\n     among other things, that it is assumed that the name of the file to patch\n     must be determined for each diff listing, and that the garbage before\n     each diff listing will be examined for interesting things such as file\n     names and revision level (see the section on Filename Determination\n     below).\n\n     The options are as follows:\n\n     -B backup-prefix, --prefix backup-prefix\n\t     Causes the next argument to be interpreted as a prefix to the\n\t     backup file name.\tIf this argument is specified, any argument to\n\t     -z will be ignored.\n\n     -b, --backup\n\t     Save a backup copy of the file before it is modified.  By default\n\t     the original file is saved with a backup extension of \".orig\"\n\t     unless the file already has a numbered backup, in which case a\n\t     numbered backup is made.  This is equivalent to specifying \"-V\n\t     existing\".\n\n     --backup-if-mismatch\n\t     Save a backup copy of the file before it is modified, but only if\n\t     a mismatch was encountered.  Specifically, this will create a\n\t     backup file if a hunk failed to apply, or if fuzz was required to\n\t     apply one or more hunks.  As with the -b option,\n\t     --backup-if-mismatch will use the existing format that is\n\t     accepted by the -V option when a backup is to be created.\n\n\t     If backups were otherwise requested with the -b option, then this\n\t     option has no effect.\n\n\t     This option is currently the default, unless --posix is\n\t     specified.\n\n     --no-backup-if-mismatch\n\t     This option negates --backup-if-mismatch, creating backups for\n\t     every file unless backups have been disabled with --posix or -V\n\t     none.\n\n     -C, --check, --dry-run\n\t     Checks that the patch would apply cleanly, but does not modify\n\t     anything.\n\n     -c, --context\n\t     Forces patch to interpret the patch file as a context diff.\n\n     -D symbol, --ifdef symbol\n\t     Causes patch to use the \"#ifdef...#endif\" construct to mark\n\t     changes.  The argument following will be used as the\n\t     differentiating symbol.  Note that, unlike the C compiler, there\n\t     must be a space between the -D and the argument.\n\n     -d directory, --directory directory\n\t     Causes patch to interpret the next argument as a directory, and\n\t     change the working directory to it before doing anything else.\n\n     -E, --remove-empty-files\n\t     Causes patch to remove output files that are empty after the\n\t     patches have been applied.  This option is useful when applying\n\t     patches that create or remove files.\n\n     -e, --ed\n\t     Forces patch to interpret the patch file as an ed(1) script.\n\n     -F max-fuzz, --fuzz max-fuzz\n\t     Sets the maximum fuzz factor.  This option only applies to\n\t     context diffs, and causes patch to ignore up to that many lines\n\t     in looking for places to install a hunk.  Note that a larger fuzz\n\t     factor increases the odds of a faulty patch.  The default fuzz\n\t     factor is 2, and it may not be set to more than the number of\n\t     lines of context in the context diff, ordinarily 3.\n\n     -f, --force\n\t     Forces patch to assume that the user knows exactly what he or she\n\t     is doing, and to not ask any questions.  It assumes the\n\t     following: skip patches for which a file to patch cannot be\n\t     found; patch files even though they have the wrong version for\n\t     the \"Prereq\": line in the patch; and assume that patches are not\n\t     reversed even if they look like they are.\tThis option does not\n\t     suppress commentary; use -s for that.\n\n     -g vcs-option, --get vcs-option\n\t     Causes patch to consult some version control systems for missing\n\t     or read-only files.  This version of patch has limited, detect-\n\t     only support for SCCS and ClearCase, but full support for RCS and\n\t     Perforce.\n\n\t     If vcs-option is set to 0, then patch will not consult any\n\t     version control system.  This is the default behavior, unless\n\t     overruled by setting the PATCH_GET environment variable.\n\n\t     If vcs-option is set to a negative number, then patch will prompt\n\t     to confirm that it is OK to checkout each file that is detected\n\t     under a supported version control system.\n\n\t     If vcs-option is set to a positive number, then patch will not\n\t     prompt before checking out each file that is detected under a\n\t     supported version control system.\n\n\t     Note that one must be in the root directory of the repository in\n\t     order for --get to work, unless patch is operating in a Perforce\n\t     workspace.\n\n\t     The --get option may also influence how a filename is chosen.\n\t     See Filename Determination below for details.\n\n     --help  Print a help message and exit.\n\n     -i patchfile, --input patchfile\n\t     Causes the next argument to be interpreted as the input file name\n\t     (i.e., a patchfile).  This option may be specified multiple\n\t     times.\n\n     -l, --ignore-whitespace\n\t     Causes the pattern matching to be done loosely, in case the tabs\n\t     and spaces have been munged in your input file.  Any sequence of\n\t     whitespace in the pattern line will match any sequence in the\n\t     input file.  Normal characters must still match exactly.  Each\n\t     line of the context must still match a line in the input file.\n\n     -N, --forward\n\t     Causes patch to ignore patches that it thinks are reversed or\n\t     already applied.  See also -R.\n\n     -n, --normal\n\t     Forces patch to interpret the patch file as a normal diff.\n\n     -o out-file, --output out-file\n\t     Causes the next argument to be interpreted as the output file\n\t     name.\n\n     -p strip-count, --strip strip-count\n\t     Sets the pathname strip count, which controls how pathnames found\n\t     in the patch file are treated, in case you keep your files in a\n\t     different directory than the person who sent out the patch.  The\n\t     strip count specifies how many slashes are to be stripped from\n\t     the front of the pathname.  (Any intervening directory names also\n\t     go away.)\tFor example, supposing the file name in the patch file\n\t     was /u/howard/src/blurfl/blurfl.c:\n\n\t     Setting -p0 gives the entire pathname unmodified.\n\n\t     -p1 gives\n\n\t\t   u/howard/src/blurfl/blurfl.c\n\n\t     without the leading slash.\n\n\t     -p4 gives\n\n\t\t   blurfl/blurfl.c\n\n\t     Not specifying -p at all just gives you blurfl.c, unless all of\n\t     the directories in the leading path (u/howard/src/blurfl) exist\n\t     and that path is relative, in which case you get the entire\n\t     pathname unmodified.  Whatever you end up with is looked for\n\t     either in the current directory, or the directory specified by\n\t     the -d option.\n\n     --quoting-style style\n\t     Controls how patch writes out filenames to the console.  The\n\t     valid values for style are:\n\n\t\t   literal\n\t\t\t   Write filenames without any special quoting.\n\n\t\t   shell   Quote filenames if they contain shell\n\t\t\t   metacharacters, or other characters that may be\n\t\t\t   problematic, e.g., spaces.\n\n\t\t   shell-always\n\t\t\t   Always quote filenames as if they contain shell\n\t\t\t   metacharacters or other problematic characters.\n\n\t\t   c\t   Quote filenames as if they are a C style string.\n\n\t\t   escape  Does the same as c, except quotes will be omitted.\n\n\t     The default quoting option is shell, unless QUOTING_STYLE is set.\n\n     -R, --reverse\n\t     Tells patch that this patch was created with the old and new\n\t     files swapped.  (Yes, I am afraid that does happen occasionally,\n\t     human nature being what it is.)  patch will attempt to swap each\n\t     hunk around before applying it.  Rejects will come out in the\n\t     swapped format.  The -R option will not work with ed diff scripts\n\t     because there is too little information to reconstruct the\n\t     reverse operation.\n\n\t     If the first hunk of a patch fails, patch will reverse the hunk\n\t     to see if it can be applied that way.  If it can, you will be\n\t     asked if you want to have the -R option set.  If it cannot, the\n\t     patch will continue to be applied normally.  (Note: this method\n\t     cannot detect a reversed patch if it is a normal diff and if the\n\t     first command is an append (i.e., it should have been a delete)\n\t     since appends always succeed, due to the fact that a null context\n\t     will match anywhere.  Luckily, most patches add or change lines\n\t     rather than delete them, so most reversed normal diffs will begin\n\t     with a delete, which will fail, triggering the heuristic.)\n\n     -r rej-name, --reject-file rej-name\n\t     Causes the next argument to be interpreted as the reject file\n\t     name.\n\n     -s, --quiet, --silent\n\t     Makes patch do its work silently, unless an error occurs.\n\n     -T, --set-time\n\t     Tells patch to set the access and modification times of the\n\t     output file based on timestamps included in the diff's header.\n\t     The -T option will force patch to assume the timestamps provided\n\t     are in the system's local timezone, unless a timezone offset is\n\t     present in the timstamp.\n\n\t     patch will not change the times on the output file unless the\n\t     original file's timestamp matches the proper file's timestamp in\n\t     the diff header and the patch context matched the original file\n\t     with neither fuzz nor offsets.  Both of these caveats are ignored\n\t     if the -f flag has been specified.\n\n     -t, --batch\n\t     Similar to -f, in that it suppresses questions, but makes some\n\t     different assumptions: skip patches for which a file to patch\n\t     cannot be found (the same as -f); skip patches for which the file\n\t     has the wrong version for the \"Prereq\": line in the patch; and\n\t     assume that patches are reversed if they look like they are.\n\n     -u, --unified\n\t     Forces patch to interpret the patch file as a unified context\n\t     diff (a unidiff).\n\n     -V t | nil | never | none, --version-control t | nil | never | none\n\t     Causes the next argument to be interpreted as a method for\n\t     creating backup file names.  The type of backups made can also be\n\t     given in the PATCH_VERSION_CONTROL or VERSION_CONTROL environment\n\t     variables, which are overridden by this option.  The -B option\n\t     overrides this option, causing the prefix to always be used for\n\t     making backup file names.\tThe values of the\n\t     PATCH_VERSION_CONTROL and VERSION_CONTROL environment variables\n\t     and the argument to the -V option are like the GNU Emacs\n\t     “version-control” variable; they also recognize synonyms that are\n\t     more descriptive.\tThe valid values are (unique abbreviations are\n\t     accepted):\n\n\t\t   t, numbered\n\t\t\t   Always make numbered backups.\n\n\t\t   nil, existing\n\t\t\t   Make numbered backups of files that already have\n\t\t\t   them, simple backups of the others.\n\n\t\t   never, simple\n\t\t\t   Always make simple backups.\n\n\t\t   none    Do not make backups.\n\n     -v, --version\n\t     Causes patch to print out its revision header and patch level.\n\n     -x number, --debug number\n\t     Sets internal debugging flags, and is of interest only to patch\n\t     patchers.\n\n     -Y prefix, --basename-prefix prefix\n\t     Prepend prefix to the basename of the file to be backed up.  For\n\t     example, specifying “-Y 0_” when patching a file\n\t     /u/howard/src/blurfl/blurfl.c will create the backup at\n\t     /u/howard/src/blurfl/0_blurfl.c.orig.\n\n     -Z, --set-utc\n\t     Tells patch to set the access and modification times of the\n\t     output file based on timestamps included in the diff's header.\n\t     The -Z option will force patch to assume the timestamps provided\n\t     are in UTC unless the timezone offset is present in the timstamp.\n\t     Note that the caveats described with the -T option about when the\n\t     output file's modification time is changed also apply to the -Z\n\t     option.\n\n     -z backup-ext, --suffix backup-ext\n\t     Causes the next argument to be interpreted as the backup\n\t     extension, to be used in place of \".orig\".\n\n     --posix\n\t     Enables strict IEEE Std 1003.1-2008 (“POSIX.1”) conformance,\n\t     specifically:\n\n\t     1.   Backup files are not created unless the -b option is\n\t\t  specified.\n\n\t     2.   If unspecified, the file name used is the first of the old,\n\t\t  new and index files that exists.\n",
        "     patch will try to skip any leading garbage, apply the diff, and then skip\n     any trailing garbage.  Thus you could feed an article or message\n     containing a diff listing to patch, and it should work.  If the entire\n     diff is indented by a consistent amount, this will be taken into account.\n\n     With context diffs, and to a lesser extent with normal diffs, patch can\n     detect when the line numbers mentioned in the patch are incorrect, and\n     will attempt to find the correct place to apply each hunk of the patch.\n     As a first guess, it takes the line number mentioned for the hunk, plus\n     or minus any offset used in applying the previous hunk.  If that is not\n     the correct place, patch will scan both forwards and backwards for a set\n     of lines matching the context given in the hunk.  First patch looks for a\n     place where all lines of the context match.  If no such place is found,\n     and it is a context diff, and the maximum fuzz factor is set to 1 or\n     more, then another scan takes place ignoring the first and last line of\n     context.  If that fails, and the maximum fuzz factor is set to 2 or more,\n     the first two and last two lines of context are ignored, and another scan\n     is made.  (The default maximum fuzz factor is 2).\n\n     If patch cannot find a place to install that hunk of the patch, it will\n     put the hunk out to a reject file, which normally is the name of the\n     output file plus \".rej\".  (Note that the rejected hunk will come out in\n     context diff form whether the input patch was a context diff or a normal\n     diff.  If the input was a normal diff, many of the contexts will simply\n     be null.)\tThe line numbers on the hunks in the reject file may be\n     different than in the patch file: they reflect the approximate location\n     patch thinks the failed hunks belong in the new file rather than the old\n     one.\n\n     As each hunk is completed, you will be told whether the hunk succeeded or\n     failed, and which line (in the new file) patch thought the hunk should go\n     on.  If this is different from the line number specified in the diff, you\n     will be told the offset.  A single large offset MAY be an indication that\n     a hunk was installed in the wrong place.  You will also be told if a fuzz\n     factor was used to make the match, in which case you should also be\n     slightly suspicious.\n",
        "     If no original file is specified on the command line, patch will try to\n     figure out from the leading garbage what the name of the file to edit is.\n     When checking a prospective file name, pathname components are stripped\n     as specified by the -p option and the file's existence and writability\n     are checked relative to the current working directory (or the directory\n     specified by the -d option).\n\n     If the diff is a context or unified diff, patch is able to determine the\n     old and new file names from the diff header.  For context diffs, the\n     “old” file is specified in the line beginning with \"***\" and the “new”\n     file is specified in the line beginning with \"---\".  For a unified diff,\n     the “old” file is specified in the line beginning with \"---\" and the\n     “new” file is specified in the line beginning with \"+++\".\tIf there is an\n     \"Index\": line in the leading garbage (regardless of the diff type), patch\n     will use the file name from that line as the “index” file.\n\n     patch will choose the file name by performing the following steps, with\n     the first match used:\n\n     1.   If patch is operating in strict IEEE Std 1003.1-2008 (“POSIX.1”)",
        "     2.   If patch is not operating in strict IEEE Std 1003.1-2008 (“POSIX.1”)",
        "     3.   If no suitable file was found to patch, the patch file is a context",
        "     4.   If the file name still cannot be determined, patch will prompt the",
        "     Additionally, if the leading garbage contains a \"Prereq: \" line, patch\n     will take the first word from the prerequisites line (normally a version\n     number) and check the input file to see if that word can be found.  If\n     not, patch will ask for confirmation before proceeding.\n\n     The upshot of all this is that you should be able to say, while in a news\n     interface, the following:\n\n\t   | patch -d /usr/src/local/blurfl\n\n     and patch a file in the blurfl directory directly from the article\n     containing the patch.\n",
        "     By default, the patched version is put in place of the original, with the\n     original file backed up to the same name with the extension \".orig\", or\n     as specified by the -B, -V, or -z options.  The extension used for making\n     backup files may also be specified in the SIMPLE_BACKUP_SUFFIX\n     environment variable, which is overridden by the options above.\n\n     If the backup file is a symbolic or hard link to the original file, patch\n     creates a new backup file name by changing the first lowercase letter in\n     the last component of the file's name into uppercase.  If there are no\n     more lowercase letters in the name, it removes the first character from\n     the name.\tIt repeats this process until it comes up with a backup file\n     that does not already exist or is not linked to the original file.\n\n     You may also specify where you want the output to go with the -o option;\n     if that file already exists, it is backed up first.\n",
        "     There are several things you should bear in mind if you are going to be\n     sending out patches:\n\n     First, you can save people a lot of grief by keeping a patchlevel.h file\n     which is patched to increment the patch level as the first diff in the\n     patch file you send out.  If you put a \"Prereq\": line in with the patch,\n     it will not let them apply patches out of order without some warning.\n\n     Second, make sure you have specified the file names right, either in a\n     context diff header, or with an \"Index\": line.  If you are patching\n     something in a subdirectory, be sure to tell the patch user to specify a\n     -p option as needed.\n\n     Third, you can create a file by sending out a diff that compares a null\n     file to the file you want to create.  If the file you want to create\n     already exists in the target directory when the diff is applied, then\n     patch will identify the patch as potentially reversed and offer to\n     reverse the patch.\n\n     Fourth, take care not to send out reversed patches, since it makes people\n     wonder whether they already applied the patch.\n\n     Fifth, while you may be able to get away with putting 582 diff listings\n     into one file, it is probably wiser to group related patches into\n     separate files in case something goes haywire.\n",
        "     PATCH_GET\t\t    Specifies the default version control behavior.\n\t\t\t    See the description of --get for valid values.\n     PATCH_VERBOSE\t    Specifies the default verbosity of patch.  Setting\n\t\t\t    PATCH_VERBOSE to a non-zero integer will enable\n\t\t\t    verbosity.\n     POSIXLY_CORRECT\t    When set, patch behaves as if the --posix option\n\t\t\t    has been specified.\n     QUOTING_STYLE\t    Specifies the default quoting style.  See the\n\t\t\t    description of --quoting-style for valid values.\n     SIMPLE_BACKUP_SUFFIX   Extension to use for backup file names instead of\n\t\t\t    \".orig\".\n     TMPDIR\t\t    Directory to put temporary files in; default is\n\t\t\t    /tmp.\n     PATCH_VERSION_CONTROL  Selects when numbered backup files are made.\n     VERSION_CONTROL\t    Same as PATCH_VERSION_CONTROL.\n",
        "     $TMPDIR/patch*  patch temporary files\n     /dev/tty\t     used to read input when patch prompts the user\n",
        "     The patch utility exits with one of the following values:\n\n\t   0\t   Successful completion.\n\t   1\t   One or more lines were written to a reject file.\n\t   >1\t   An error occurred.\n\n     When applying a set of patches in a loop it behooves you to check this\n     exit status so you do not apply a later patch to a partially patched\n     file.\n",
        "     Too many to list here, but generally indicative that patch couldn't parse\n     your patch file.\n\n     The message \"Hmm...\" indicates that there is unprocessed text in the\n     patch file and that patch is attempting to intuit whether there is a\n     patch in that text and, if so, what kind of patch it is.\n",
        "     diff(1)\n",
        "     The patch utility is compliant with the IEEE Std 1003.1-2008 (“POSIX.1”)\n     specification, except as detailed above for the --posix option.\n\n     The flags [-BCEFfstVvxz] and [--posix] are extensions to that\n     specification.\n",
        "     Larry Wall with many other contributors.\n",
        "     patch cannot tell if the line numbers are off in an ed script, and can\n     only detect bad line numbers in a normal diff when it finds a \"change\" or\n     a \"delete\" command.  A context diff using fuzz factor 3 may have the same\n     problem.  Until a suitable interactive interface is added, you should\n     probably do a context diff in these cases to see if the changes made\n     sense.  Of course, compiling without errors is a pretty good indication\n     that the patch worked, but not always.\n\n     patch usually produces the correct results, even when it has to do a lot\n     of guessing.  However, the results are guaranteed to be correct only when\n     the patch is applied to exactly the same version of the file that the\n     patch was generated from.\n",
        "     Could be smarter about partial matches, excessively deviant offsets and\n     swapped code, but that would take an extra pass.\n\n     Check patch mode (-C) will fail if you try to check several patches in\n     succession that build on each other.  The entire patch code would have to\n     be restructured to keep temporary files around so that it can handle this\n     situation.\n\n     If code has been duplicated (for instance with #ifdef OLDCODE ... #else\n     ...  #endif), patch is incapable of patching both versions, and, if it\n     works at all, will likely patch the wrong one, and tell you that it\n     succeeded to boot.\n\n     If you apply a patch you have already applied, patch will think it is a\n     reversed patch, and offer to un-apply the patch.  This could be construed\n     as a feature.\n"
      ]
    }
  ],
  "flags": [
    {
      "flag": "-B",
      "description": " Causes the next argument to be interpreted as a prefix to the backup file name.\tIf this argument is specified, any argument to",
      "optional": true
    },
    {
      "flag": "-z",
      "description": " Causes the next argument to be interpreted as the backup extension, to be used in place of \".orig\".",
      "optional": true
    },
    {
      "flag": "--backup-if-mismatch",
      "description": " Save a backup copy of the file before it is modified, but only if a mismatch was encountered.  Specifically, this will create a backup file if a hunk failed to apply, or if fuzz was required to apply one or more hunks.  As with the -b option,",
      "shortFlag": "-b"
    },
    {
      "flag": "--backup-if-mismatch",
      "description": "will use the existing format that is accepted by the -V option when a backup is to be created. If backups were otherwise requested with the -b option, then this option has no effect. This option is currently the default, unless --posix is specified."
    },
    {
      "flag": "--no-backup-if-mismatch",
      "description": " This option negates --backup-if-mismatch, creating backups for every file unless backups have been disabled with --posix or -V none."
    },
    {
      "flag": "-C",
      "description": ", --check, --dry-run Checks that the patch would apply cleanly, but does not modify anything."
    },
    {
      "flag": "-c",
      "description": ", --context Forces patch to interpret the patch file as a context diff."
    },
    {
      "flag": "-D",
      "description": " Causes patch to use the \"#ifdef...#endif\" construct to mark changes.  The argument following will be used as the differentiating symbol.  Note that, unlike the C compiler, there must be a space between the -D and the argument.",
      "optional": true
    },
    {
      "flag": "-d",
      "description": " Causes patch to interpret the next argument as a directory, and change the working directory to it before doing anything else.",
      "optional": true
    },
    {
      "flag": "-E",
      "description": ", --remove-empty-files Causes patch to remove output files that are empty after the patches have been applied.  This option is useful when applying patches that create or remove files."
    },
    {
      "flag": "-e",
      "description": ", --ed Forces patch to interpret the patch file as an ed(1) script."
    },
    {
      "flag": "-F",
      "description": " Sets the maximum fuzz factor.  This option only applies to context diffs, and causes patch to ignore up to that many lines in looking for places to install a hunk.  Note that a larger fuzz factor increases the odds of a faulty patch.  The default fuzz factor is 2, and it may not be set to more than the number of lines of context in the context diff, ordinarily 3.",
      "optional": true
    },
    {
      "flag": "-f",
      "description": ", --force Forces patch to assume that the user knows exactly what he or she is doing, and to not ask any questions.  It assumes the following: skip patches for which a file to patch cannot be found; patch files even though they have the wrong version for the \"Prereq\": line in the patch; and assume that patches are not reversed even if they look like they are.\tThis option does not suppress commentary; use -s for that."
    },
    {
      "flag": "--help",
      "description": "Print a help message and exit.",
      "shortFlag": "-g"
    },
    {
      "flag": "-i",
      "description": " Causes the next argument to be interpreted as the input file name (i.e., a patchfile).  This option may be specified multiple times.",
      "optional": true
    },
    {
      "flag": "-l",
      "description": ", --ignore-whitespace Causes the pattern matching to be done loosely, in case the tabs and spaces have been munged in your input file.  Any sequence of whitespace in the pattern line will match any sequence in the input file.  Normal characters must still match exactly.  Each line of the context must still match a line in the input file."
    },
    {
      "flag": "-N",
      "description": ", --forward Causes patch to ignore patches that it thinks are reversed or already applied.  See also -R."
    },
    {
      "flag": "-n",
      "description": ", --normal Forces patch to interpret the patch file as a normal diff."
    },
    {
      "flag": "-o",
      "description": " Causes the next argument to be interpreted as the output file name.",
      "optional": true
    },
    {
      "flag": "-p",
      "description": " Sets the pathname strip count, which controls how pathnames found in the patch file are treated, in case you keep your files in a different directory than the person who sent out the patch.  The strip count specifies how many slashes are to be stripped from the front of the pathname.  (Any intervening directory names also go away.)\tFor example, supposing the file name in the patch file was /u/howard/src/blurfl/blurfl.c: Setting -p0 gives the entire pathname unmodified. Third, you can create a file by sending out a diff that compares a null file to the file you want to create.  If the file you want to create already exists in the target directory when the diff is applied, then patch will identify the patch as potentially reversed and offer to reverse the patch. Fourth, take care not to send out reversed patches, since it makes people wonder whether they already applied the patch. Fifth, while you may be able to get away with putting 582 diff listings into one file, it is probably wiser to group related patches into separate files in case something goes haywire.",
      "optional": true
    },
    {
      "flag": "-p1",
      "description": "gives u/howard/src/blurfl/blurfl.c without the leading slash."
    },
    {
      "flag": "--quoting-style",
      "description": " Controls how patch writes out filenames to the console.  The valid values for style are: literal Write filenames without any special quoting. shell   Quote filenames if they contain shell metacharacters, or other characters that may be problematic, e.g., spaces. shell-always Always quote filenames as if they contain shell metacharacters or other problematic characters. c\t   Quote filenames as if they are a C style string. escape  Does the same as c, except quotes will be omitted. The default quoting option is shell, unless QUOTING_STYLE is set.",
      "optional": true,
      "shortFlag": "-p4"
    },
    {
      "flag": "-R",
      "description": ", --reverse Tells patch that this patch was created with the old and new files swapped.  (Yes, I am afraid that does happen occasionally, human nature being what it is.)  patch will attempt to swap each hunk around before applying it.  Rejects will come out in the swapped format.  The -R option will not work with ed diff scripts because there is too little information to reconstruct the reverse operation. If the first hunk of a patch fails, patch will reverse the hunk to see if it can be applied that way.  If it can, you will be asked if you want to have the -R option set.  If it cannot, the patch will continue to be applied normally.  (Note: this method cannot detect a reversed patch if it is a normal diff and if the first command is an append (i.e., it should have been a delete) since appends always succeed, due to the fact that a null context will match anywhere.  Luckily, most patches add or change lines rather than delete them, so most reversed normal diffs will begin with a delete, which will fail, triggering the heuristic.)"
    },
    {
      "flag": "-r",
      "description": " Causes the next argument to be interpreted as the reject file name.",
      "optional": true
    },
    {
      "flag": "-s",
      "description": ", --quiet, --silent Makes patch do its work silently, unless an error occurs."
    },
    {
      "flag": "-T",
      "description": " Tells patch to set the access and modification times of the output file based on timestamps included in the diff's header. The -T option will force patch to assume the timestamps provided are in the system's local timezone, unless a timezone offset is present in the timstamp. patch will not change the times on the output file unless the original file's timestamp matches the proper file's timestamp in the diff header and the patch context matched the original file with neither fuzz nor offsets.  Both of these caveats are ignored if the -f flag has been specified.",
      "optional": true
    },
    {
      "flag": "-t",
      "description": ", --batch Similar to -f, in that it suppresses questions, but makes some different assumptions: skip patches for which a file to patch cannot be found (the same as -f); skip patches for which the file has the wrong version for the \"Prereq\": line in the patch; and assume that patches are reversed if they look like they are."
    },
    {
      "flag": "-u",
      "description": ", --unified Forces patch to interpret the patch file as a unified context diff (a unidiff)."
    },
    {
      "flag": "-V",
      "description": " Causes the next argument to be interpreted as a method for creating backup file names.  The type of backups made can also be given in the PATCH_VERSION_CONTROL or VERSION_CONTROL environment variables, which are overridden by this option.  The -B option overrides this option, causing the prefix to always be used for making backup file names.\tThe values of the PATCH_VERSION_CONTROL and VERSION_CONTROL environment variables and the argument to the -V option are like the GNU Emacs “version-control” variable; they also recognize synonyms that are more descriptive.\tThe valid values are (unique abbreviations are accepted): t, numbered Always make numbered backups. nil, existing Make numbered backups of files that already have them, simple backups of the others. never, simple Always make simple backups. none    Do not make backups.",
      "optional": true
    },
    {
      "flag": "-v",
      "description": ", --version Causes patch to print out its revision header and patch level."
    },
    {
      "flag": "-x",
      "description": " Sets internal debugging flags, and is of interest only to patch patchers.",
      "optional": true
    },
    {
      "flag": "-Y",
      "description": " Prepend prefix to the basename of the file to be backed up.  For example, specifying “-Y 0_” when patching a file /u/howard/src/blurfl/blurfl.c will create the backup at /u/howard/src/blurfl/0_blurfl.c.orig.",
      "optional": true
    },
    {
      "flag": "-Z",
      "description": " Tells patch to set the access and modification times of the output file based on timestamps included in the diff's header. The -Z option will force patch to assume the timestamps provided are in UTC unless the timezone offset is present in the timstamp. Note that the caveats described with the -T option about when the output file's modification time is changed also apply to the -Z option.",
      "optional": false
    },
    {
      "flag": "--posix",
      "description": " Enables strict IEEE Std 1003.1-2008 (“POSIX.1”) conformance, specifically: 1.   Backup files are not created unless the -b option is specified. 2.   If unspecified, the file name used is the first of the old, new and index files that exists. Patch Application patch will try to skip any leading garbage, apply the diff, and then skip any trailing garbage.  Thus you could feed an article or message containing a diff listing to patch, and it should work.  If the entire diff is indented by a consistent amount, this will be taken into account. With context diffs, and to a lesser extent with normal diffs, patch can detect when the line numbers mentioned in the patch are incorrect, and will attempt to find the correct place to apply each hunk of the patch. As a first guess, it takes the line number mentioned for the hunk, plus or minus any offset used in applying the previous hunk.  If that is not the correct place, patch will scan both forwards and backwards for a set of lines matching the context given in the hunk.  First patch looks for a place where all lines of the context match.  If no such place is found, and it is a context diff, and the maximum fuzz factor is set to 1 or more, then another scan takes place ignoring the first and last line of context.  If that fails, and the maximum fuzz factor is set to 2 or more, the first two and last two lines of context are ignored, and another scan is made.  (The default maximum fuzz factor is 2). If patch cannot find a place to install that hunk of the patch, it will put the hunk out to a reject file, which normally is the name of the output file plus \".rej\".  (Note that the rejected hunk will come out in context diff form whether the input patch was a context diff or a normal diff.  If the input was a normal diff, many of the contexts will simply be null.)\tThe line numbers on the hunks in the reject file may be different than in the patch file: they reflect the approximate location patch thinks the failed hunks belong in the new file rather than the old one. As each hunk is completed, you will be told whether the hunk succeeded or failed, and which line (in the new file) patch thought the hunk should go on.  If this is different from the line number specified in the diff, you will be told the offset.  A single large offset MAY be an indication that a hunk was installed in the wrong place.  You will also be told if a fuzz factor was used to make the match, in which case you should also be slightly suspicious. Filename Determination If no original file is specified on the command line, patch will try to figure out from the leading garbage what the name of the file to edit is. When checking a prospective file name, pathname components are stripped as specified by the -p option and the file's existence and writability are checked relative to the current working directory (or the directory specified by the -d option). If the diff is a context or unified diff, patch is able to determine the old and new file names from the diff header.  For context diffs, the “old” file is specified in the line beginning with \"***\" and the “new” file is specified in the line beginning with \"---\".  For a unified diff, the “old” file is specified in the line beginning with \"---\" and the “new” file is specified in the line beginning with \"+++\".\tIf there is an \"Index\": line in the leading garbage (regardless of the diff type), patch will use the file name from that line as the “index” file. patch will choose the file name by performing the following steps, with the first match used: 1.   If patch is operating in strict IEEE Std 1003.1-2008 (“POSIX.1”) mode, the first of the “old”, “new” and “index” file names that exist is used. 2.   If patch is not operating in strict IEEE Std 1003.1-2008 (“POSIX.1”) mode, and a non-zero --get argument has been supplied, then patch will choose one of the “index”, “old” or “new” filenames that are detected to exist under a version control system.  Otherwise, patch will examine either the “old” and “new” file names or, for a non- context diff, the “index” file name, and choose the file name with the fewest path components, the shortest basename, and the shortest total file name length (in that order). 3.   If no suitable file was found to patch, the patch file is a context or unified diff, and the old file was zero length, the new file name is created and used. 4.   If the file name still cannot be determined, patch will prompt the user for the file name to use. Additionally, if the leading garbage contains a \"Prereq: \" line, patch will take the first word from the prerequisites line (normally a version number) and check the input file to see if that word can be found.  If not, patch will ask for confirmation before proceeding. The upshot of all this is that you should be able to say, while in a news interface, the following: | patch -d /usr/src/local/blurfl and patch a file in the blurfl directory directly from the article containing the patch. Backup Files By default, the patched version is put in place of the original, with the original file backed up to the same name with the extension \".orig\", or as specified by the -B, -V, or -z options.  The extension used for making backup files may also be specified in the SIMPLE_BACKUP_SUFFIX environment variable, which is overridden by the options above. If the backup file is a symbolic or hard link to the original file, patch creates a new backup file name by changing the first lowercase letter in the last component of the file's name into uppercase.  If there are no more lowercase letters in the name, it removes the first character from the name.\tIt repeats this process until it comes up with a backup file that does not already exist or is not linked to the original file. You may also specify where you want the output to go with the -o option; if that file already exists, it is backed up first. Notes For Patch Senders There are several things you should bear in mind if you are going to be sending out patches: First, you can save people a lot of grief by keeping a patchlevel.h file which is patched to increment the patch level as the first diff in the patch file you send out.  If you put a \"Prereq\": line in with the patch, it will not let them apply patches out of order without some warning. Second, make sure you have specified the file names right, either in a context diff header, or with an \"Index\": line.  If you are patching something in a subdirectory, be sure to tell the patch user to specify a",
      "optional": true,
      "shortFlag": "-z"
    },
    {
      "flag": "-p",
      "description": " Sets the pathname strip count, which controls how pathnames found in the patch file are treated, in case you keep your files in a different directory than the person who sent out the patch.  The strip count specifies how many slashes are to be stripped from the front of the pathname.  (Any intervening directory names also go away.)\tFor example, supposing the file name in the patch file was /u/howard/src/blurfl/blurfl.c: Setting -p0 gives the entire pathname unmodified. Third, you can create a file by sending out a diff that compares a null file to the file you want to create.  If the file you want to create already exists in the target directory when the diff is applied, then patch will identify the patch as potentially reversed and offer to reverse the patch. Fourth, take care not to send out reversed patches, since it makes people wonder whether they already applied the patch. Fifth, while you may be able to get away with putting 582 diff listings into one file, it is probably wiser to group related patches into separate files in case something goes haywire.",
      "optional": true
    }
  ],
  "examples": [],
  "relatedCommands": [
    "patch",
    "apply",
    "diff",
    "original",
    "backup-prefix",
    "symbol",
    "directory",
    "vcs-option",
    "max-fuzz",
    "patchfile",
    "out-file",
    "strip-count",
    "rej-name",
    "nil",
    "never"
  ],
  "seeAlso": [],
  "metadata": {},
  "searchContent": "patch patch manual page patch will take a patch file containing any of the four forms of difference listing produced by the diff 1 program and apply those differences to an original file producing a patched version patch -bcceeflnnrstuv -b backup-prefix -d symbol -d directory -g vcs-option -f max-fuzz -i patchfile -o out-file -p strip-count -r rej-name -t -z -v t nil never none -x number -y prefix -z backup-ext --quoting-style style --posix origfile patchfile patch patchfile patch manual page take containing four forms difference listing produced diff 1 program apply those differences original file producing patched version -b causes the next argument to be interpreted as a prefix to the backup file name if this argument is specified any argument to -z causes the next argument to be interpreted as the backup extension to be used in place of orig --backup-if-mismatch save a backup copy of the file before it is modified but only if a mismatch was encountered specifically this will create a backup file if a hunk failed to apply or if fuzz was required to apply one or more hunks as with the -b option --backup-if-mismatch will use the existing format that is accepted by the -v option when a backup is to be created if backups were otherwise requested with the -b option then this option has no effect this option is currently the default unless --posix is specified --no-backup-if-mismatch this option negates --backup-if-mismatch creating backups for every file unless backups have been disabled with --posix or -v none -c --check --dry-run checks that the patch would apply cleanly but does not modify anything -c --context forces patch to interpret the patch file as a context diff -d causes patch to use the ifdef endif construct to mark changes the argument following will be used as the differentiating symbol note that unlike the c compiler there must be a space between the -d and the argument -d causes patch to interpret the next argument as a directory and change the working directory to it before doing anything else -e --remove-empty-files causes patch to remove output files that are empty after the patches have been applied this option is useful when applying patches that create or remove files -e --ed forces patch to interpret the patch file as an ed 1 script -f sets the maximum fuzz factor this option only applies to context diffs and causes patch to ignore up to that many lines in looking for places to install a hunk note that a larger fuzz factor increases the odds of a faulty patch the default fuzz factor is 2 and it may not be set to more than the number of lines of context in the context diff ordinarily 3 -f --force forces patch to assume that the user knows exactly what he or she is doing and to not ask any questions it assumes the following skip patches for which a file to patch cannot be found patch files even though they have the wrong version for the prereq line in the patch and assume that patches are not reversed even if they look like they are this option does not suppress commentary use -s for that --help print a help message and exit -i causes the next argument to be interpreted as the input file name i e a patchfile this option may be specified multiple times -l --ignore-whitespace causes the pattern matching to be done loosely in case the tabs and spaces have been munged in your input file any sequence of whitespace in the pattern line will match any sequence in the input file normal characters must still match exactly each line of the context must still match a line in the input file -n --forward causes patch to ignore patches that it thinks are reversed or already applied see also -r -n --normal forces patch to interpret the patch file as a normal diff -o causes the next argument to be interpreted as the output file name -p sets the pathname strip count which controls how pathnames found in the patch file are treated in case you keep your files in a different directory than the person who sent out the patch the strip count specifies how many slashes are to be stripped from the front of the pathname any intervening directory names also go away for example supposing the file name in the patch file was u howard src blurfl blurfl c setting -p0 gives the entire pathname unmodified third you can create a file by sending out a diff that compares a null file to the file you want to create if the file you want to create already exists in the target directory when the diff is applied then patch will identify the patch as potentially reversed and offer to reverse the patch fourth take care not to send out reversed patches since it makes people wonder whether they already applied the patch fifth while you may be able to get away with putting 582 diff listings into one file it is probably wiser to group related patches into separate files in case something goes haywire -p1 gives u howard src blurfl blurfl c without the leading slash --quoting-style controls how patch writes out filenames to the console the valid values for style are literal write filenames without any special quoting shell quote filenames if they contain shell metacharacters or other characters that may be problematic e g spaces shell-always always quote filenames as if they contain shell metacharacters or other problematic characters c quote filenames as if they are a c style string escape does the same as c except quotes will be omitted the default quoting option is shell unless quoting style is set -r --reverse tells patch that this patch was created with the old and new files swapped yes i am afraid that does happen occasionally human nature being what it is patch will attempt to swap each hunk around before applying it rejects will come out in the swapped format the -r option will not work with ed diff scripts because there is too little information to reconstruct the reverse operation if the first hunk of a patch fails patch will reverse the hunk to see if it can be applied that way if it can you will be asked if you want to have the -r option set if it cannot the patch will continue to be applied normally note this method cannot detect a reversed patch if it is a normal diff and if the first command is an append i e it should have been a delete since appends always succeed due to the fact that a null context will match anywhere luckily most patches add or change lines rather than delete them so most reversed normal diffs will begin with a delete which will fail triggering the heuristic -r causes the next argument to be interpreted as the reject file name -s --quiet --silent makes patch do its work silently unless an error occurs -t tells patch to set the access and modification times of the output file based on timestamps included in the diff s header the -t option will force patch to assume the timestamps provided are in the system s local timezone unless a timezone offset is present in the timstamp patch will not change the times on the output file unless the original file s timestamp matches the proper file s timestamp in the diff header and the patch context matched the original file with neither fuzz nor offsets both of these caveats are ignored if the -f flag has been specified -t --batch similar to -f in that it suppresses questions but makes some different assumptions skip patches for which a file to patch cannot be found the same as -f skip patches for which the file has the wrong version for the prereq line in the patch and assume that patches are reversed if they look like they are -u --unified forces patch to interpret the patch file as a unified context diff a unidiff -v causes the next argument to be interpreted as a method for creating backup file names the type of backups made can also be given in the patch version control or version control environment variables which are overridden by this option the -b option overrides this option causing the prefix to always be used for making backup file names the values of the patch version control and version control environment variables and the argument to the -v option are like the gnu emacs version-control variable they also recognize synonyms that are more descriptive the valid values are unique abbreviations are accepted t numbered always make numbered backups nil existing make numbered backups of files that already have them simple backups of the others never simple always make simple backups none do not make backups -v --version causes patch to print out its revision header and patch level -x sets internal debugging flags and is of interest only to patch patchers -y prepend prefix to the basename of the file to be backed up for example specifying -y 0 when patching a file u howard src blurfl blurfl c will create the backup at u howard src blurfl 0 blurfl c orig -z tells patch to set the access and modification times of the output file based on timestamps included in the diff s header the -z option will force patch to assume the timestamps provided are in utc unless the timezone offset is present in the timstamp note that the caveats described with the -t option about when the output file s modification time is changed also apply to the -z option --posix enables strict ieee std 1003 1-2008 posix 1 conformance specifically 1 backup files are not created unless the -b option is specified 2 if unspecified the file name used is the first of the old new and index files that exists patch application patch will try to skip any leading garbage apply the diff and then skip any trailing garbage thus you could feed an article or message containing a diff listing to patch and it should work if the entire diff is indented by a consistent amount this will be taken into account with context diffs and to a lesser extent with normal diffs patch can detect when the line numbers mentioned in the patch are incorrect and will attempt to find the correct place to apply each hunk of the patch as a first guess it takes the line number mentioned for the hunk plus or minus any offset used in applying the previous hunk if that is not the correct place patch will scan both forwards and backwards for a set of lines matching the context given in the hunk first patch looks for a place where all lines of the context match if no such place is found and it is a context diff and the maximum fuzz factor is set to 1 or more then another scan takes place ignoring the first and last line of context if that fails and the maximum fuzz factor is set to 2 or more the first two and last two lines of context are ignored and another scan is made the default maximum fuzz factor is 2 if patch cannot find a place to install that hunk of the patch it will put the hunk out to a reject file which normally is the name of the output file plus rej note that the rejected hunk will come out in context diff form whether the input patch was a context diff or a normal diff if the input was a normal diff many of the contexts will simply be null the line numbers on the hunks in the reject file may be different than in the patch file they reflect the approximate location patch thinks the failed hunks belong in the new file rather than the old one as each hunk is completed you will be told whether the hunk succeeded or failed and which line in the new file patch thought the hunk should go on if this is different from the line number specified in the diff you will be told the offset a single large offset may be an indication that a hunk was installed in the wrong place you will also be told if a fuzz factor was used to make the match in which case you should also be slightly suspicious filename determination if no original file is specified on the command line patch will try to figure out from the leading garbage what the name of the file to edit is when checking a prospective file name pathname components are stripped as specified by the -p option and the file s existence and writability are checked relative to the current working directory or the directory specified by the -d option if the diff is a context or unified diff patch is able to determine the old and new file names from the diff header for context diffs the old file is specified in the line beginning with and the new file is specified in the line beginning with --- for a unified diff the old file is specified in the line beginning with --- and the new file is specified in the line beginning with if there is an index line in the leading garbage regardless of the diff type patch will use the file name from that line as the index file patch will choose the file name by performing the following steps with the first match used 1 if patch is operating in strict ieee std 1003 1-2008 posix 1 mode the first of the old new and index file names that exist is used 2 if patch is not operating in strict ieee std 1003 1-2008 posix 1 mode and a non-zero --get argument has been supplied then patch will choose one of the index old or new filenames that are detected to exist under a version control system otherwise patch will examine either the old and new file names or for a non- context diff the index file name and choose the file name with the fewest path components the shortest basename and the shortest total file name length in that order 3 if no suitable file was found to patch the patch file is a context or unified diff and the old file was zero length the new file name is created and used 4 if the file name still cannot be determined patch will prompt the user for the file name to use additionally if the leading garbage contains a prereq line patch will take the first word from the prerequisites line normally a version number and check the input file to see if that word can be found if not patch will ask for confirmation before proceeding the upshot of all this is that you should be able to say while in a news interface the following patch -d usr src local blurfl and patch a file in the blurfl directory directly from the article containing the patch backup files by default the patched version is put in place of the original with the original file backed up to the same name with the extension orig or as specified by the -b -v or -z options the extension used for making backup files may also be specified in the simple backup suffix environment variable which is overridden by the options above if the backup file is a symbolic or hard link to the original file patch creates a new backup file name by changing the first lowercase letter in the last component of the file s name into uppercase if there are no more lowercase letters in the name it removes the first character from the name it repeats this process until it comes up with a backup file that does not already exist or is not linked to the original file you may also specify where you want the output to go with the -o option if that file already exists it is backed up first notes for patch senders there are several things you should bear in mind if you are going to be sending out patches first you can save people a lot of grief by keeping a patchlevel h file which is patched to increment the patch level as the first diff in the patch file you send out if you put a prereq line in with the patch it will not let them apply patches out of order without some warning second make sure you have specified the file names right either in a context diff header or with an index line if you are patching something in a subdirectory be sure to tell the patch user to specify a -p sets the pathname strip count which controls how pathnames found in the patch file are treated in case you keep your files in a different directory than the person who sent out the patch the strip count specifies how many slashes are to be stripped from the front of the pathname any intervening directory names also go away for example supposing the file name in the patch file was u howard src blurfl blurfl c setting -p0 gives the entire pathname unmodified third you can create a file by sending out a diff that compares a null file to the file you want to create if the file you want to create already exists in the target directory when the diff is applied then patch will identify the patch as potentially reversed and offer to reverse the patch fourth take care not to send out reversed patches since it makes people wonder whether they already applied the patch fifth while you may be able to get away with putting 582 diff listings into one file it is probably wiser to group related patches into separate files in case something goes haywire name macos 15 5 april 27 2022 macos 15 5",
  "keywords": [
    "patch",
    "manual",
    "page",
    "take",
    "containing",
    "four",
    "forms",
    "difference",
    "listing",
    "produced",
    "diff(1)",
    "program",
    "apply",
    "those",
    "differences",
    "original",
    "file,",
    "producing",
    "patched",
    "version."
  ],
  "complexity": "advanced",
  "hash": "7b3da1bdd6c7c13e",
  "parsedAt": "2025-06-17T19:31:57.971Z",
  "parseVersion": "2.0.0",
  "isCommon": false,
  "hasInteractiveExamples": false,
  "hasDiagrams": false
}